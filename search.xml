<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Flex 布局</title>
    <url>/chayaBlog/2020/01/10/css/Flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><p><strong>需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</strong></p>
<h2 id="Flex-容器："><a href="#Flex-容器：" class="headerlink" title="Flex 容器："></a>Flex 容器：</h2><p>有下面六种属性可以设置在容器上，它们分别是：</p>
<ol>
<li><strong>flex-direction</strong>（决定主轴的方向）</li>
<li><strong>flex-wrap</strong>（决定容器内项目是否可换行）</li>
<li>flex-flow</li>
<li><strong>justify-content</strong>（主轴的对齐方式）</li>
<li><strong>align-items</strong>（交叉轴上的对齐方式）</li>
<li>align-content</li>
</ol>
<ul>
<li><h4 id="flex-direction-决定主轴的方向-即项目的排列方向"><a href="#flex-direction-决定主轴的方向-即项目的排列方向" class="headerlink" title="flex-direction:  决定主轴的方向(即项目的排列方向)"></a>flex-direction:  决定主轴的方向(即项目的排列方向)</h4></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="flex-wrap-决定容器内项目是否可换行"><a href="#flex-wrap-决定容器内项目是否可换行" class="headerlink" title="flex-wrap: 决定容器内项目是否可换行"></a>flex-wrap: 决定容器内项目是否可换行</h4></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="flex-flow-flex-direction-和-flex-wrap-的简写形式"><a href="#flex-flow-flex-direction-和-flex-wrap-的简写形式" class="headerlink" title="flex-flow: flex-direction 和 flex-wrap 的简写形式"></a>flex-flow: flex-direction 和 flex-wrap 的简写形式</h4></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"> <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="justify-content：定义了项目在主轴的对齐方式"><a href="#justify-content：定义了项目在主轴的对齐方式" class="headerlink" title="justify-content：定义了项目在主轴的对齐方式"></a>justify-content：定义了项目在主轴的对齐方式</h4></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between |     space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="align-items-定义了项目在交叉轴上的对齐方式"><a href="#align-items-定义了项目在交叉轴上的对齐方式" class="headerlink" title="align-items: 定义了项目在交叉轴上的对齐方式"></a>align-items: 定义了项目在交叉轴上的对齐方式</h4></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"> <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="align-content-定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用"><a href="#align-content-定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用" class="headerlink" title="align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用"></a>align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用</h4></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Flex-Item-属性："><a href="#Flex-Item-属性：" class="headerlink" title="Flex Item 属性："></a>Flex Item 属性：</h2><p>有六种属性可运用在 item 项目上：</p>
<ol>
<li><strong>order</strong>（容器中的排列顺序）</li>
<li><strong>flex-grow</strong> （项目的放大比例）</li>
<li><strong>flex-shrink</strong>（项目的缩小比例）</li>
<li><strong>flex-basis</strong>（项目占据的主轴空间）</li>
<li><strong>flex</strong></li>
<li><strong>align-self</strong>（单个项目的对齐方式）</li>
</ol>
<ul>
<li><h4 id="order-定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为-0"><a href="#order-定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为-0" class="headerlink" title="order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0"></a>order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0</h4></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="flex-grow-定义项目的放大比例"><a href="#flex-grow-定义项目的放大比例" class="headerlink" title="flex-grow: 定义项目的放大比例"></a>flex-grow: 定义项目的放大比例</h4></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="flex-shrink-定义了项目的缩小比例"><a href="#flex-shrink-定义了项目的缩小比例" class="headerlink" title="flex-shrink: 定义了项目的缩小比例"></a>flex-shrink: 定义了项目的缩小比例</h4></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="flex-basis-定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间"><a href="#flex-basis-定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间" class="headerlink" title="flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间"></a>flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间</h4></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="flex-flex-grow-flex-shrink-和-flex-basis的简写"><a href="#flex-flex-grow-flex-shrink-和-flex-basis的简写" class="headerlink" title="flex: flex-grow, flex-shrink 和 flex-basis的简写"></a>flex: flex-grow, flex-shrink 和 flex-basis的简写</h4></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关快捷值：auto (1 1 auto) 和 none (0 0 auto)</p>
<ul>
<li><h4 id="align-self-允许单个项目有与其他项目不一样的对齐方式"><a href="#align-self-允许单个项目有与其他项目不一样的对齐方式" class="headerlink" title="align-self: 允许单个项目有与其他项目不一样的对齐方式"></a>align-self: 允许单个项目有与其他项目不一样的对齐方式</h4></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">     <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>BFC</title>
    <url>/chayaBlog/2020/03/13/css/BFC/</url>
    <content><![CDATA[<p><strong>BFC(Block Formatting Context)</strong> 是一个独立的渲染区域，让处于BFC内部的元素和外部的元素相互隔离，使内外元素的定位不会相互影响。</p>
<h3 id="触发条件："><a href="#触发条件：" class="headerlink" title="触发条件："></a>触发条件：</h3><ul>
<li>根元素(<html>)</html></li>
<li>position : absolute , fixed;</li>
<li>overflow !== visible</li>
<li>float !== none</li>
<li>display : flow-root, inline-block,  table, inline-table, table-cell, table-caption, table-row, table-row-group, table-header-group, table-footer-group</li>
<li>display : flex, inline-flex, grid, inline-grid 的直接子元素</li>
</ul>
<h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h3><ul>
<li>属于同一个BFC的两个相邻的Box垂直排列</li>
<li>属于同一个BFC的两个相邻的Box的外边距会合并(Mastering Margin Collapsing)</li>
<li>BFC 中子元素的margin box的左边与包含块(BFC)border box的左边相接触（子元素absolute除外）</li>
<li>BFC的区域不会与float元素区域重叠</li>
<li>计算BFC的高度时，浮动子元素也参与计算</li>
<li>文字层不会被浮动层覆盖，环绕与周围</li>
</ul>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul>
<li><p><strong>让浮动内容和周围的内容等高</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    background-color: rgb(224, 206, 247);</span><br><span class="line">    border: 5px solid rebeccapurple;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.float &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background-color: white;</span><br><span class="line">    border:1px solid black;</span><br><span class="line">    padding: 10px;</span><br><span class="line">&#125;      </span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;float&quot;&gt;I am a floated box!&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;I am content inside the container.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>效果： <img src="https://raw.githubusercontent.com/hcyisgakusei/chayaBlog/gh-pages/images/bfc1.png" alt="bfc"><br>解决方案：设置 overflow: auto 创建一个新的BFC来包含这个浮动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">   background-color: rgb(224, 206, 247);</span><br><span class="line">   border: 5px solid rebeccapurple;</span><br><span class="line">   overflow: auto; // 创建BFC</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>效果： <img src="https://raw.githubusercontent.com/hcyisgakusei/chayaBlog/gh-pages/images/bfc2.png" alt="bfc"></p>
</li>
</ul>
<ul>
<li><p><strong>解决外边距合并</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.yellow, .pink-inner &#123;</span><br><span class="line">  height: 50px;</span><br><span class="line">  margin: 10px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.yellow &#123;</span><br><span class="line">  background: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.pink-inner&#123;</span><br><span class="line">  background:pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果（yellow inner 和 pink inner 的边距为10px，不是20px）：<br><img src="https://raw.githubusercontent.com/hcyisgakusei/chayaBlog/gh-pages/images/bfc3.png" alt="bfc"><br>解决方案： 设置display: flow-root 创建一个新的BFC</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.pink-outer &#123;</span><br><span class="line">  display: flow-root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果（yellow inner 和 pink inner 的边距为20px）：<br><img src="https://raw.githubusercontent.com/hcyisgakusei/chayaBlog/gh-pages/images/bfc4.png" alt="bfc"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>JS DOM  Attribute VS Property</title>
    <url>/chayaBlog/2019/11/26/js/Dom-Attribute-VS-Property/</url>
    <content><![CDATA[<h3 id="Attribute-VS-Property"><a href="#Attribute-VS-Property" class="headerlink" title="Attribute VS Property"></a>Attribute VS Property</h3><ul>
<li><h5 id="Attribute-是我们在-HTML-代码中看到的键值对，例如"><a href="#Attribute-是我们在-HTML-代码中看到的键值对，例如" class="headerlink" title="Attribute 是我们在 HTML 代码中看到的键值对，例如"></a>Attribute 是我们在 HTML 代码中看到的键值对，例如</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"test"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  上面代码中的 input 节点有三个 attribute，通过<code>getAttribute</code>可以获取对应的值:</p>
<ul>
<li>id : name</li>
<li>type : text</li>
<li>value : test</li>
</ul>
<ul>
<li><h5 id="Property-是-attribute对应的DOM节点的对象属性，例如"><a href="#Property-是-attribute对应的DOM节点的对象属性，例如" class="headerlink" title="Property 是 attribute对应的DOM节点的对象属性，例如"></a>Property 是 attribute对应的DOM节点的对象属性，例如</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTMLInputElement.id === <span class="string">'name'</span></span><br><span class="line">HTMLInputElement.type === <span class="string">'text'</span></span><br><span class="line">HTMLInputElement.value === <span class="string">'test'</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="Attribute-和-Property-的区别"><a href="#Attribute-和-Property-的区别" class="headerlink" title="Attribute 和 Property 的区别"></a>Attribute 和 Property 的区别</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"typo"</span> <span class="attr">value</span>=<span class="string">"test"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 页面加载之后，在input中输入 Jack --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  注意这段代码中的 type 属性, 我们给的值是 <strong>typo</strong>, 这并不属于 input 支持的 type 种类.</p>
<p>  上面这个 input 节点的 attribute 和 property:</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// attribute still remains the original value</span></span><br><span class="line">input.getAttribute(<span class="string">'id'</span>) <span class="comment">// name</span></span><br><span class="line">input.getAttribute(<span class="string">'type'</span>) <span class="comment">// typo</span></span><br><span class="line">input.getAttribute(<span class="string">'value'</span>) <span class="comment">// test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// property is a different story</span></span><br><span class="line">input.id <span class="comment">// name</span></span><br><span class="line">input.type <span class="comment">//  text</span></span><br><span class="line">input.value <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>
<p>  可以看到, 在 attribute 中, 值仍然是 html 代码中的值. 而在 property 中, type 被自动修正为了 <strong>text</strong>, 而 value 随着用户改变 input 的输入, 也变更为了 <strong>Jack</strong></p>
<p>  这就是 <strong>attribute</strong> 和 <strong>Property</strong> 间的区别:</p>
<p>  a<strong>t</strong>tribute 会始终保持 html 代码中的<strong>初始值</strong>, 而 <strong>Property</strong> 是有可能变化的.</p>
<p>  其实, 我们从这两个单词的名称也能看出些端倪:</p>
<p>  <strong>attribute</strong> 从语义上, 更倾向于不可变更的</p>
<p>  而 <strong>property</strong> 从语义上更倾向于在其生命周期中是可变的</p>
<ul>
<li><h5 id="Attribute可以自定义，但是Property不可以"><a href="#Attribute可以自定义，但是Property不可以" class="headerlink" title="Attribute可以自定义，但是Property不可以"></a>Attribute可以自定义，但是Property不可以</h5><p>在 html 中自定义 attribute:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"customInput"</span> <span class="attr">customeAttr</span>=<span class="string">"custome attribute value"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  获取自定义的属性:</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">input.getAttribute(<span class="string">'customAttr'</span>) <span class="comment">// custome attribute value</span></span><br><span class="line">input.customAttr <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>  能够成功的获取自定义的 attribute, 但是无法获取 property.</p>
<p>  DOM 节点在初始化的时候会将<strong>html 规范</strong>中定义的 attribute 赋值到 property 上, 而自定义的 attribute 并不属于这个氛围内, 自然生成的 DOM 节点就没有这个 property.</p>
<ul>
<li><h5 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h5><p>需要注意, 有一些特殊的 attribute, 它们对应的 Property 名称会发生改变, 比如:</p>
<ul>
<li>for (attr) =&gt; htmlFor (prop)</li>
<li>class (attr) =&gt; className (prop)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>js 对象与hash表</title>
    <url>/chayaBlog/2019/01/26/js/hash%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="hash-表"><a href="#hash-表" class="headerlink" title="hash 表"></a>hash 表</h2><p>哈希表也叫散列表，我们在中使用的对象就是一种hash结构。哈希表根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<h3 id="hash表的结构"><a href="#hash表的结构" class="headerlink" title="hash表的结构"></a>hash表的结构</h3><p>hash表的结构本质上是结合了数组和链表两种结构。</p>
<p>数组：寻址容易，插入和删除困难，需要预先给定数组的大小<br>链表：寻址困难，插入和删除容易，不需要预先给定空间</p>
<p>hash 表的可以看做是一个存储链表的数组。</p>
<h3 id="hash-函数"><a href="#hash-函数" class="headerlink" title="hash 函数"></a>hash 函数</h3><p>我们对哈希表进行put操作的时候，底层会对 key 用hash函数映射到数组中。哈希函数需要具有以下几个特点：</p>
<ul>
<li>运算过程要尽量简单高效，以提高哈希表的插入和检索效率；</li>
<li>哈希函数应该具有较好的散列型，以降低哈希冲突的概率；</li>
<li>哈希函数应具有较大的压缩性，以节省内存。</li>
</ul>
<p>常用的方法有以下几种：</p>
<ul>
<li>直接地址法：以关键字的某个线性函数值为哈希地址，可以表示为hash(K)=aK+C;优点是不会产生冲突，缺点是空间复杂度可能会较高，适用于元素较少的情况</li>
<li>除留余数法：它是由数据元素关键字除以某个常数所留的余数为哈希地址，该方法计算简单，适用范围广，是经常使用的一种哈希函数</li>
<li>数字分析法：该方法是取数据元素关键字中某些取值较均匀的数字来作为哈希地址的方法，这样可以尽量避免冲突，但是该方法只适合于所有关键字已知的情况，对于想要设计出更加通用的哈希表并不适用</li>
<li>平方求和法：对当前字串转化为Unicode值，并求出这个值的平方，去平方值中间的几位为当前数字的hash值，具体取几位要取决于当前哈希表的大小。</li>
<li>分段求和法：根据当前哈希表的位数把所要插入的数值分成若干段，把若干段进行相加，舍去调最高位结果就是这个值的哈希值。</li>
</ul>
<h3 id="hash-冲突"><a href="#hash-冲突" class="headerlink" title="hash 冲突"></a>hash 冲突</h3><p>当两个不同key通过hash函数映射到了数组同一个地址中，此时就存在了hash冲突。</p>
<p>哈希冲突主要与两个因素有关：</p>
<ul>
<li>填装因子，填装因子是指哈希表中已存入的数据元素个数与哈希地址空间的大小的比值，a=n/m ; a越小，冲突的可能性就越小，相反则冲突可能性较大；但是a越小空间利用率也就越小，a越大，空间利用率越高，为了兼顾哈希冲突和存储空间利用率，通常将a控制在0.6-0.9之间，</li>
<li>与所用的哈希函数有关，如果哈希函数得当，就可以使哈希地址尽可能的均匀分布在哈希地址空间上，从而减少冲突的产生，但一个良好的哈希函数的得来很大程度上取决于大量的实践，</li>
</ul>
<h4 id="解决-hash冲突"><a href="#解决-hash冲突" class="headerlink" title="解决 hash冲突"></a>解决 hash冲突</h4><p>一般使用拉链法来解决这个问题。即不在数组中直接存储value而是存储一个链表，当存在hash冲突的时候只需要在冲突的位置的结尾加多一个节点。</p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>一般我们会预先设定一个临界值，当达到临界值会对hash表进行扩容操作，不过扩容操作是非常损耗性能的</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>[].slice.call(arguments) 转数组的原理</title>
    <url>/chayaBlog/2018/03/16/js/prototype-slice/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([].slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<p>我们经常可以看到一些文档或者比人的源码之中用这种方式把<code>arguments</code>转化为数组,但是为什么可以这样子操作呢，现在我们可以看一下<code>Array.prototype.slice</code> 他的实现原理是怎样的。</p>
<h3 id="slice-的原理"><a href="#slice-的原理" class="headerlink" title="slice 的原理"></a>slice 的原理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice = <span class="function"><span class="keyword">function</span>(<span class="params">begin, end</span>) </span>&#123;</span><br><span class="line">      end = (<span class="keyword">typeof</span> end !== <span class="string">'undefined'</span>) ? end : <span class="keyword">this</span>.length;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">var</span> i, </span><br><span class="line">        cloned = [],</span><br><span class="line">        size, </span><br><span class="line">        len = <span class="keyword">this</span>.length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> start = begin || <span class="number">0</span>;</span><br><span class="line">      start = (start &gt;= <span class="number">0</span>) ? start : <span class="built_in">Math</span>.max(<span class="number">0</span>, len + start);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> upTo = (<span class="keyword">typeof</span> end == <span class="string">'number'</span>) ? <span class="built_in">Math</span>.min(end, len) : len;</span><br><span class="line">      <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        upTo = len + end;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      size = upTo - start;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cloned = <span class="keyword">new</span> <span class="built_in">Array</span>(size);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.charAt) &#123;</span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            cloned[i] = <span class="keyword">this</span>.charAt(start + i);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            cloned[i] = <span class="keyword">this</span>[start + i];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以到 <code>slice</code> 其实是在用 <code>this</code> 访问对象的属性，通过<code>call</code>将<code>arguments</code>绑定到<code>this</code>上，以此可以遍历出 <code>arguments</code> 的全部参数。</p>
<p>通过 <code>slice</code> 的底层原理我们也可以看出，如果我们传一个字符串进去，会把字符串转化为数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[].slice.call(&apos;12345&apos;); // [1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<h3 id="ES6的新方法"><a href="#ES6的新方法" class="headerlink" title="ES6的新方法"></a>ES6的新方法</h3><p>ES6 给 <code>Array</code> 新加了一个方法，我们也可以通过他把 arguments 转化为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>:<span class="number">2</span>,<span class="number">0</span>:<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;) <span class="comment">// [1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
<p>相比于 <code>slice</code>，<code>from</code> 更强大一点，<code>from</code> 还可以将带有遍历器属性<code>[Symbol.iterator]</code>的对象转化为数组</p>
<p>例如我们可以这样操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = &#123;&#125;</span><br><span class="line">test[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.from(test);<span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>JS This 指向</title>
    <url>/chayaBlog/2020/01/19/js/this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="this-、apply、-call、bind"><a href="#this-、apply、-call、bind" class="headerlink" title="this 、apply、 call、bind"></a>this 、apply、 call、bind</h1><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p>在ES5中，<strong>this永远指向最后调用它的那个对象</strong></p>
<p><strong>匿名函数的 this 永远指向 window</strong></p>
<ul>
<li><strong>例子1</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowName"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"aName"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// windowsName</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inner"</span>,<span class="keyword">this</span>); <span class="comment">// inner: Window</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer:"</span>,  <span class="keyword">this</span>); <span class="comment">// outer: Window</span></span><br></pre></td></tr></table></figure>
<p>“<strong>this 永远指向最后调用它的那个对象</strong>”，调用 <code>a</code> 的地方 <code>a();</code>，前面没有调用的对象那么就是全局对象 window，这就相当于是 <code>window.a()</code>；注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 <code>undefined</code>，那么就会报错 <code>Uncaught TypeError: Cannot read property &#39;name&#39; of undefined</code>。</p>
<ul>
<li><p><strong>例子2</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">     name: <span class="string">"aName"</span>,</span><br><span class="line">     fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// aName</span></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> a.fn();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  函数<code>fn</code>是对象a调用的，所有<code>this</code>指向的就是<code>a</code></p>
<ul>
<li><strong>例子3</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">      name: <span class="string">"aName"</span>,</span><br><span class="line">      fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// aName</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.a.fn();</span><br></pre></td></tr></table></figure>
<p>因为<strong>this永远指向最后调用它的那个对象</strong>，所以<code>fn</code>中的<code>this</code>还是指向<code>a</code></p>
<ul>
<li><strong>例子4</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">       name :<span class="string">"aName"</span>,</span><br><span class="line">       fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> f = a.fn;</span><br><span class="line"> f();</span><br></pre></td></tr></table></figure>
<p>因为虽然将 <code>a</code> 对象的<code>fn</code> 方法赋值给变量<code>f</code>了，但是没有调用，<strong>this 永远指向最后调用它的那个对象</strong>。由于刚刚的 <code>f</code> 并没有调用，所以 <code>fn()</code> 最后仍然是被 <code>window</code> 调用的。所以 <code>this</code> 指向的也就是 <code>window</code>。</p>
<ul>
<li><p><strong>例子5</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> name = <span class="string">"fnName"</span>;</span><br><span class="line">      innerFunction();</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  记住：<strong>this永远指向最后调用它的那个对象！！！！</strong></p>
<h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h2><ul>
<li>使用 ES6 的箭头函数</li>
<li>在函数内部使用 <code>_this = this</code></li>
<li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li>
<li>new 实例化一个对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">        name : <span class="string">"aName"</span>,</span><br><span class="line">        func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)     </span><br><span class="line">        &#125;,</span><br><span class="line">        func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            setTimeout( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.func1()</span><br><span class="line">            &#125;,<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">a.func2();     <span class="comment">// this.func1 is not a function</span></span><br></pre></td></tr></table></figure>
<p>是会报错，因为最后调用 <code>setTimeout</code> 的对象是 <code>window</code>，但是在 window<code></code>中并没有 <code>func1</code> 函数。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><strong>箭头函数里面根本没有自己的<code>this</code>，而是引用外层的<code>this</code>。</strong></p>
<p><strong>箭头函数的this始终指向函数定义时的this，而非执行时。</strong> 箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值。如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">       name : <span class="string">"aName"</span>,</span><br><span class="line">       func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)     </span><br><span class="line">       &#125;,</span><br><span class="line">       func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">               <span class="keyword">this</span>.func1()</span><br><span class="line">           &#125;,<span class="number">100</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">a.func2();     <span class="comment">// aName</span></span><br></pre></td></tr></table></figure>
<h2 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 <code>_this = this</code></h2><p>在不使用es6的情况下，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 <code>_this</code> 中，然后在函数中都使用这个 <code>_this</code>，这样 <code>_this</code> 就不会改变了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">       name : <span class="string">"aName"</span>,</span><br><span class="line">       func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)     </span><br><span class="line">       &#125;,</span><br><span class="line">       func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">           setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">               _this.func1()</span><br><span class="line">           &#125;,<span class="number">100</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">a.func2();  <span class="comment">// aName</span></span><br></pre></td></tr></table></figure>
<p>在 <code>func2</code> 中，首先设置 <code>var _this = this;</code>，这里的 <code>this</code> 是调用 <code>func2</code> 的对象 <code>a</code>，为了防止在 <code>func2</code> 中的 setTimeout 被 <code>window</code> 调用而导致的在 <code>setTimeout</code> 中的 <code>this</code> 为 <code>window</code>。我们将 <code>this</code>(指向变量 <code>a</code>) 赋值给一个变量 <code>_this</code>，这样，在 <code>func2</code> 中我们使用 <code>_this</code> 就是指向对象 <code>a</code> 了。</p>
<h2 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h2><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"aName"</span>,</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// 'aName'</span></span><br><span class="line">     &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">str1,str2</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;str1&#125;</span> &amp; <span class="subst">$&#123;str2&#125;</span>`</span>); <span class="comment">// 'test1 &amp; test2'</span></span><br><span class="line">          <span class="keyword">this</span>.func1();</span><br><span class="line">         &#125;).apply(a,[<span class="string">'test1'</span>,<span class="string">'test2'</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">a.func2();</span><br></pre></td></tr></table></figure>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"aName"</span>,</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">     &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         (<span class="function"><span class="keyword">function</span>(<span class="params">str1,str2</span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;str1&#125;</span> &amp; <span class="subst">$&#123;str2&#125;</span>`</span>); <span class="comment">// 'test1 &amp; test2'</span></span><br><span class="line">           <span class="keyword">this</span>.func1();</span><br><span class="line">         &#125;).call(a,<span class="string">'test1'</span>,<span class="string">'test2'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">a.func2();        <span class="comment">// aName</span></span><br></pre></td></tr></table></figure>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"aName"</span>,</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">     &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         (<span class="function"><span class="keyword">function</span>(<span class="params">str1,str2</span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;str1&#125;</span> &amp; <span class="subst">$&#123;str2&#125;</span>`</span>); <span class="comment">// 'test1 &amp; test2'</span></span><br><span class="line">           <span class="keyword">this</span>.func1();</span><br><span class="line">         &#125;).bind(a,<span class="string">'test1'</span>,<span class="string">'test2'</span>)();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">a.func2();        <span class="comment">// aName</span></span><br></pre></td></tr></table></figure>
<p>### </p>
<h3 id="new-的过程"><a href="#new-的过程" class="headerlink" title="new 的过程"></a>new 的过程</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new myFunction</span></span><br><span class="line">(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = myFunction.propertype;</span><br><span class="line">    <span class="keyword">const</span> result = myFunction.call(obj,...arguments);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>js事件代理</title>
    <url>/chayaBlog/2018/03/20/js/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>比如说我们想个一个列表中的每一项绑定一个点击事件，如果我们一个一个去给每一项绑定事件，则会导致多次操纵dom，效率也比较低，如果添加一个新的选项的话，还得再给这个选项绑定事件。</p>
<p>事件代理，其实就是将事件绑定在父元素上，然后通过父元素的点击事件来判断点击的是不是子元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id=&quot;test&quot;&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var ul = document.getElementById(&apos;test&apos;)</span><br><span class="line">    ul.addEventListener(&apos;click&apos;, function (event) &#123;</span><br><span class="line">        var target = event.target</span><br><span class="line">        if (target.tagName.toUpperCase() === &apos;LI&apos;) &#123;</span><br><span class="line">            console.log(target.innerText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>我们通过绑定父元素的点击事件，通过获取 <code>event.target</code> 可以知道当前点击的元素，在 IE 6-8中不支持该属性，有一个 <code>srcElement</code> 等价于这里 <code>target</code></p>
<h3 id="currentTarget"><a href="#currentTarget" class="headerlink" title="currentTarget"></a>currentTarget</h3><p>如果我们打印出 <code>event</code> 可以看到里面有一个 <code>currentTarget</code> 属性，并且这个属性为 null，那么这个属性有什么用呢。</p>
<p>这里我们可以这样试一下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>)</span></span><br><span class="line"><span class="javascript">    ul.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.currentTarget)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.target)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>event.currentTarget</code>打印出来的是ul节点。根据 mdn 的文档可知该属性是指向当前事件被绑定的元素上<br><code>event.target</code>打印出来的是所点击的li节点。根据 mdn 的文档可知该属性是指向触发事件的元素上</p>
<p>在js中<code>console.log(obj)</code>打印对象的时候，是对对象的一个引用，如果对象的属性后面被改变了，打印出来的对象也是会发生改变的，所以造成了前面打印 <code>event</code> 的时候发现他的<code>currentTarget</code>为null</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>js 作用域与闭包</title>
    <url>/chayaBlog/2018/03/19/js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>在 <code>let</code> 和 <code>const</code> 出现之前，js 是没有会计作用域的， 在我们使用 <code>var</code> 定义变量的时候，是有可能会导致变量提升的。</p>
<p><strong>比如</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这段代码最后会输出2，这是因为var 导致了变量 i 的提升，在有了 let之后我们用let就不会有这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">// error i is not defined</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>我们先看看这段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>
<p>上面这段代码会依次输出，1，2，error b is not defined，</p>
<p>在js中函数是有自己的作用域的，函数内部定义的变量，外部是无法直接访问到的，只有函数内部才能够直接访问。</p>
<p>函数内部在调用 <code>inner()</code> ，在访问 b 这个变量的时候，会先看自己的作用域中是否有这个变量，发现没有，然后再查找 test 的作用域，发现了这个变量，然后就输出这个变量。</p>
<p>这里外部无法访问到test中的b，所以在函数执行完之后，b会被销毁掉。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>我们先来看一下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countResult</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="built_in">console</span>.log(cout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tmp = countResult();</span><br><span class="line"><span class="keyword">var</span> tmp2 = countResult();</span><br><span class="line">tmp(); <span class="comment">// 1</span></span><br><span class="line">tmp2(); <span class="comment">// 1</span></span><br><span class="line">tmp(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这里虽然我们无法直接访问到 <code>countResult</code> 中的变量count，但是我们通过返回的函数可以间接的访问到count，tmp保持着对count的引用，所以tmp 中的count不会被销毁，我们再新生成一个tmp2，可以发现，tmp和tmp2之间的作用域是不同的，他们都有自己单独的局部作用域。</p>
<p>闭包的作用主要有两点：</p>
<ol>
<li>隔离作用域</li>
<li>使局部变量能够常驻内存</li>
</ol>
<p>同样闭包带来的问题也非常明显：</p>
<ol>
<li>闭包会使得函数中的变量都被保存到内存中，导致内存消耗很大。在使用闭包的时候，退出函数之前，我们需要将一些不使用的局部变量全部删除。</li>
</ol>
<h2 id="js-的垃圾回收机制"><a href="#js-的垃圾回收机制" class="headerlink" title="js 的垃圾回收机制"></a>js 的垃圾回收机制</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>应有计数通过计算变量的引用数来回收垃圾，如果一个值的引用数为0则将其回收</p>
<p>引用计数法会存在一个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">    var a = &#123;&#125;;</span><br><span class="line">    var b= &#123;&#125;;</span><br><span class="line">    a.b=b;</span><br><span class="line">    b.a=a;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>test 中的 a和b互相引用了对方，但是这里执行完之后本该销毁这两个变量，如果使用引用计数法的话，就不会销毁这两个变量而导致内存泄露。</p>
<h3 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h3><p>标记清除法是通过根节点向下访问，如果能访问到的都不会被清除，在浏览器中根节点就 <code>window</code>, 这样就避免了循环引用导致的内存泄露问题。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>js 数组元素与数组长度</title>
    <url>/chayaBlog/2018/03/23/js/%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>在 js 中我们可以用如下的方法创建数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [empty*3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>
<p>第一种是我们常用的一种创建数组的方法</p>
<p>第二种则会生成一个length为3的数组对象，我们访问 arr2[0] 返回的是 undefined</p>
<p>这里我们需要注意一点的是，arr2 不会初始化 arr2[0],arr2[1],arr[2],这句话是什么意思呢，看看下面这个例子你就明白了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> <span class="keyword">in</span> arr); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> <span class="keyword">in</span> arr2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 new Arry(3) 效果是一样的，注意这里是四个逗号</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [,,,,]</span><br></pre></td></tr></table></figure>
<h2 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h2><p>通常我们在修改数组的时候都是这样子修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>我们还可以这样操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//  [1, 2, 3, empty × 7, 10]</span></span><br></pre></td></tr></table></figure>
<p>这里会导致和<code>new Array(10)</code>的结果有点类似</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> <span class="keyword">in</span> arr); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>arr[10] = 10</code> 虽然会让数组的长度增加，但实际上却未真正的增加了数组的元素。</p>
<h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 0，1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 啥都没输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">undefined</span>,,]</span><br><span class="line"><span class="built_in">console</span>.log(arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;));<span class="comment">// [1,2,3,undefined]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/chayaBlog/2020/04/20/js/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>1.贪婪匹配和惰性匹配<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 贪婪匹配和惰性匹配 </span></span><br><span class="line"><span class="comment"> * 正则使用量词&#123; &#125; 匹配的话是贪婪匹配的  尽可能多的匹配 </span></span><br><span class="line"><span class="comment"> * 惰性匹配  尽可能少的匹配 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//能匹配尽量多的次数   </span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;1,3&#125;/g</span>;</span><br><span class="line"><span class="comment">//console.log("123857823748".match(reg));</span></span><br><span class="line"><span class="comment">// [ '123', '857', '823', '748' ]</span></span><br><span class="line"><span class="comment">//d&#123;1&#125;  惰性匹配</span></span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/\d&#123;1,3&#125;?/g</span>;</span><br><span class="line"><span class="comment">//console.log("123".match(reg1));</span></span><br><span class="line"><span class="comment">// [ '1', '2', '3' ]</span></span><br><span class="line"><span class="comment">/**  量词后面加上？ 就表示惰性匹配 </span></span><br><span class="line"><span class="comment"> *   &#123;m,n&#125;?  </span></span><br><span class="line"><span class="comment"> *   &#123;m,&#125;?</span></span><br><span class="line"><span class="comment"> *   ??</span></span><br><span class="line"><span class="comment"> *   +?</span></span><br><span class="line"><span class="comment"> *   *?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//以此类推直到匹配成功或不剩字符才停止。</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/(\d&#123;1,2&#125;)(\d&#123;3,4&#125;)/g</span>;   <span class="comment">//贪婪模式  </span></span><br><span class="line"><span class="keyword">var</span> reg3 = <span class="regexp">/(\d&#123;1,2&#125;?)(\d&#123;3,4&#125;?)/g</span>;   <span class="comment">//惰性模式 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//贪婪</span></span><br><span class="line"><span class="built_in">console</span>.log(motify(<span class="string">"1234563231"</span>,reg2));</span><br><span class="line"><span class="built_in">console</span>.log(motify(<span class="string">"12345"</span>,reg2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//惰性</span></span><br><span class="line"><span class="built_in">console</span>.log(motify(<span class="string">"1234563"</span>,reg3));</span><br><span class="line"><span class="built_in">console</span>.log(motify(<span class="string">"1234"</span>,reg3));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">motify</span>(<span class="params">str,reg</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(reg,(item,$<span class="number">1</span>,$<span class="number">2</span>)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item+<span class="string">"==&gt;"</span>+$<span class="number">1</span>+<span class="string">"~"</span>+$<span class="number">2</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>正则位置的匹配</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/单词边界 \b   \B</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[string,string] hello wrold"</span>.replace(<span class="regexp">/\b/g</span>,<span class="string">"#"</span>));</span><br><span class="line"><span class="comment">//[#string#,#string#] #hello# #wrold#</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[string,string] hello wrold"</span>.replace(<span class="regexp">/\B/g</span>,<span class="string">"+"</span>));</span><br><span class="line"><span class="comment">//+[s+t+r+i+n+g,s+t+r+i+n+g]+ h+e+l+l+o w+r+o+l+d</span></span><br><span class="line"></span><br><span class="line">断言  (?=exp)  (?!exp)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>.replace(<span class="regexp">/(?=l)/g</span>,<span class="string">"&amp;"</span>));</span><br><span class="line"><span class="comment">//   he&amp;l&amp;lo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>.replace(<span class="regexp">/(?!l)/g</span>,<span class="string">"-"</span>));</span><br><span class="line"><span class="comment">//   -h-ell-o-</span></span><br><span class="line"></span><br><span class="line">使用断言的场景 一般是对于位置的操作  </span><br><span class="line"><span class="comment">// ?=exp   右侧的位置能匹配exp  exp 右边的位置 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>.replace(<span class="regexp">/(?=l)/g</span>,<span class="string">"&amp;"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ?!exp   右侧的位置不能匹配exp</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>.replace(<span class="regexp">/(?!l)/g</span>,<span class="string">"-"</span>));</span><br><span class="line"></span><br><span class="line">千位分隔符表示法</span><br><span class="line"><span class="comment">// 如果要把"12345678"替换成"12,345,678"  </span></span><br><span class="line"><span class="comment">// 从后往前 每三位前面的位置加一个,   str.repalce(/(?=(\d&#123;3&#125;)+\b)/g,",")   </span></span><br><span class="line"><span class="comment">//console.log("123456789".replace(/(?=(\d&#123;3&#125;)+\b)/g,","));</span></span><br><span class="line"><span class="comment">// 不能匹配开头  "123456789"    </span></span><br><span class="line"> <span class="comment">//var reg1 =/(?!^)(?=(\d&#123;3&#125;)+$)/g;     </span></span><br><span class="line"><span class="comment">//console.log("123456789".replace(reg1,","));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是需要匹配 "12345678 123456"     </span></span><br><span class="line"><span class="keyword">var</span> reg2 =<span class="regexp">/(?!\b)(?=(\d&#123;3&#125;)+\b)/g</span>;</span><br><span class="line"><span class="comment">// var reg2 = /\B(?=(\d&#123;3&#125;)+\b)/g;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"123453 1234324234"</span>.replace(reg2,<span class="string">","</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">money</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">''</span>+num).replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+(?!\d))/g</span>, <span class="string">'$1,'</span>).replace(<span class="regexp">/$/g</span>,<span class="string">"¥"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">console</span>.log(money(<span class="string">"312312321 38578374589"</span>));</span><br><span class="line"> <span class="built_in">console</span>.log(money(<span class="string">"123456789 74587374892347"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//密码的校验 </span></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *  密码长度6-12位，由数字、小写字符和大写字母组成，必须三种字符都包括</span></span><br><span class="line"><span class="comment"> *  前瞻断言 、后瞻断言(js不支持)</span></span><br><span class="line"><span class="comment"> *  顺序肯定环视 ：  (?=exp)  表示所在位置右侧能够匹配exp </span></span><br><span class="line"><span class="comment"> *  顺序否定环视 ：  (?!exp)  表示所在位置右侧不能匹配exp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//必须包含数字 （?=.*[0-9])^[0-9a-zA-Z_]&#123;6,12&#125;$   </span></span><br><span class="line"> <span class="keyword">var</span> reg3 = <span class="regexp">/(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])^[0-9a-zA-Z_]&#123;6,12&#125;$/g</span>;  </span><br><span class="line"> <span class="built_in">console</span>.log(reg5.test(<span class="string">"1AA23heh313"</span>));</span><br><span class="line"><span class="comment">//  console.log(reg3.test("123123123"));</span></span><br><span class="line"><span class="comment">//  console.log(reg3.test("dewwe23123"));</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**  </span></span><br><span class="line"><span class="comment">  * 密码长度6-12位，由数字、小写字符和大写字母组成，  但必须至少包括2种字符。</span></span><br><span class="line"><span class="comment">  * 同时包含数字和小写字母      (?=.*[0-9])(?=.*[a-z])</span></span><br><span class="line"><span class="comment">  * 同时包含数字和大写字母      (?=.*[0-9])(?=.*[A-Z])</span></span><br><span class="line"><span class="comment">  * 同时包含小写字母和大写字母   (?=.*[a-z])(?=.*[A-Z])</span></span><br><span class="line"><span class="comment">  * var reg = /((?=.*[0-9])(?=.*[a-z]))|(?=.*[0-9])(?=.*[A-Z])|((?=.*[a-z])(?=.*[A-Z])))/g;</span></span><br><span class="line"><span class="comment">  * 另一种想法 ：</span></span><br><span class="line"><span class="comment">  * 必须至少包括两种字符    所以不能只包含某种字符</span></span><br><span class="line"><span class="comment">  * var reg = /(?!^[0-9]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/  不能只包含数字  </span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * //最后：(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>JS 类型判断</title>
    <url>/chayaBlog/2020/02/24/js/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h2 id="JS类型判断"><a href="#JS类型判断" class="headerlink" title="JS类型判断"></a>JS类型判断</h2><h4 id="js7种数据类型"><a href="#js7种数据类型" class="headerlink" title="js7种数据类型"></a>js7种数据类型</h4><blockquote>
<p><strong>基本类型：</strong> Boolean、Number、String、Undefined、Null、Symbol</p>
<p><strong>引用类型：</strong> Object</p>
</blockquote>
<p><strong>基本类型</strong>也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。</p>
<p><strong>引用类型</strong>也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等。</p>
<h3 id="数据类型判断的4种方法"><a href="#数据类型判断的4种方法" class="headerlink" title="数据类型判断的4种方法"></a>数据类型判断的4种方法</h3><ul>
<li><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4></li>
</ul>
<blockquote>
<p>typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">''</span>; <span class="comment">// string 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// number 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// symbol 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">//boolean 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">//undefined 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> [] ; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>(); <span class="comment">// function 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(); <span class="comment">//object 无效</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>对于基本类型，除 null 以外，均可以返回正确的结果。</p>
</li>
<li><p>对于引用类型，除 function 以外，一律返回 object 类型。</p>
</li>
</ol>
<ul>
<li><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4></li>
</ul>
<blockquote>
<p>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：<strong>instanceof 检测的是原型</strong></p>
</blockquote>
<p>我们用一段伪代码来模拟其内部执行过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">instanceof</span>(A,B)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> A.__proto__ === B.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>;<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> Person;</span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Person <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例</p>
<p>[ ].<strong>proto</strong>  指向 Array.prototype，而 Array.prototype.<strong>proto</strong> 又指向了Object.prototype，最终 Object.prototype.<strong>proto</strong> 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链</p>
<p><strong>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</strong></p>
<p>针对数组的这个问题，ES5 提供了 <strong>Array.isArray()</strong> 方法 。</p>
<ul>
<li><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4></li>
</ul>
<p>当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">''</span>.constructor === <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).constructor === <span class="built_in">Number</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>().constructor === <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().constructor === <span class="built_in">Date</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Error</span>().constructor === <span class="built_in">Error</span>; <span class="comment">// true</span></span><br><span class="line">[].constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;).constructor ===<span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">document</span>.constructor === HTMLDocument; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">window</span>.constructor === Window; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p>
</li>
<li><p>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</p>
</li>
</ol>
<ul>
<li><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4></li>
</ul>
<blockquote>
<p>toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</p>
<p>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>);   <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>);    <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>); <span class="comment">// "[object Boolean]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">// "[object Symbol]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(newFunction()); <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(newDate()); <span class="comment">// "[object Date]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(newRegExp()); <span class="comment">// "[object RegExp]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(newError()); <span class="comment">// "[object Error]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>); <span class="comment">// "[object HTMLDocument]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>); <span class="comment">// "[object global]" window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>快速理解js继承原理</title>
    <url>/chayaBlog/2018/03/10/js/%E7%BB%A7%E6%89%BF%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="JS继承原理"><a href="#JS继承原理" class="headerlink" title="JS继承原理"></a>JS继承原理</h2><p>js 的继承是通过原型链来实现的</p>
<h3 id="什么是原型链呢？"><a href="#什么是原型链呢？" class="headerlink" title="什么是原型链呢？"></a>什么是原型链呢？</h3><p>首先说一下 <code>prototype</code> 属性，在js中所有的方法都会有一个<code>prototype</code>属性,这个属性就是方法的原型对象</p>
<p>比方说：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.run=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Animal()</span><br></pre></td></tr></table></figure>
<p>当我们声明 Animal 这个方法的时候， js引擎会赋予Animal一个原型对象，打印出来可以看到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Animal.prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    constructor:这个指向 Animal这个方法,</span></span><br><span class="line"><span class="comment">    __proto__:这个指向Object.prototype</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<p>在我们构造实例的时候,cat的<code>__proto__</code> 会指向 Animal 的 <code>prototype</code>, js引擎 在访问对象的属性的时候会先查看当前对象是否这个属性，如果没有则会查看改对象的 <code>__proto__</code> 是否有这个属性，访问会沿着原型链访问下去直到找到属性或者 <code>__proto__</code>为null为止。</p>
<h3 id="如何实现继承"><a href="#如何实现继承" class="headerlink" title="如何实现继承"></a>如何实现继承</h3><p>这里只讲通用的一种继承的写法</p>
<p>这是父类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is run'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里通过调用父类并把this绑定到父类上</span></span><br><span class="line">    Animal.call(<span class="keyword">this</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 这里其实本质要做的就是让Cat.prototype.__proto__=Animal.prototype</span></span><br><span class="line">    <span class="comment">// Cat.prototype =Object.create(Animal.prototype) 相当于做了如下的工作</span></span><br><span class="line">    <span class="comment">// Cat.prototype.__proto__ = Animal.prototype;</span></span><br><span class="line"></span><br><span class="line">    Cat.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">    Cat.prototype.constructor = Cat;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h3 id="ES6-的写法："><a href="#ES6-的写法：" class="headerlink" title="ES6 的写法："></a>ES6 的写法：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Class Animal&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is run'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class Cat extends Animal&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="comment">// ES6要求子类构造函数中必须要调用这个方法，这个方式是用来调用父类的constructor的</span></span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实es6的写法本质上上面的语法糖，使用之后代码对代码的可读性有了明显的提高，但是我们还是需要知道JS继承的原理是怎样的。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>搭建私有NPM</title>
    <url>/chayaBlog/2019/08/15/tools/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%20npm/</url>
    <content><![CDATA[<p>目前有以下两种推荐方案：</p>
<h2 id="使用-verdaccio"><a href="#使用-verdaccio" class="headerlink" title="使用 verdaccio"></a>使用 <code>verdaccio</code></h2><p><a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">verdaccio</a>: A lightweight private npm proxy registry</p>
<h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>在服务器上全局安装 <code>verdaccio</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g verdaccio</span><br><span class="line">$ verdaccio</span><br><span class="line">warn --- config file - /home/.config/verdaccio/config.yaml </span><br><span class="line">warn --- http address - http://localhost:4873/ - verdaccio/3.0.0</span><br></pre></td></tr></table></figure>
<h3 id="Nginx-setting"><a href="#Nginx-setting" class="headerlink" title="Nginx setting"></a>Nginx setting</h3><p>为了不和其他的 <code>Nginx</code>配置冲突，我们将 <code>verdaccio</code> 的默认端口指向服务器的子目录 <code>/verdaccio/</code> 下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  concierge11.klook.io;</span><br><span class="line"></span><br><span class="line">  location ~ ^/verdaccio/(.*)$ &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:4873/$1;</span><br><span class="line">    proxy_set_header Host            $host:$server_port;</span><br><span class="line">    proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时我们还需要修改 <code>verdaccio</code> 的配置文件 <code>~/.config/verdaccio/config.yaml</code>，更多<a href="https://bitbucket.org/jogiterding/mypro/src/3cc4c7f5f15f3817af3882bdf532aeacc4f660e2/%5Bhttps:/verdaccio.org/docs/en/configuration%5D(https:/verdaccio.org/docs/en/configuration" target="_blank" rel="noopener">配置参考</a>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url_prefix:  /verdaccio/</span><br></pre></td></tr></table></figure>
<ul>
<li><code>~/.config/verdaccio/storage</code> ：储存发布和缓存的包，会缓存下载的包</li>
<li><code>~/.config/verdaccio/htpasswd</code> ：储存注册用户的账号名和密码</li>
</ul>
<h3 id="Keeping-verdaccio-running-forever"><a href="#Keeping-verdaccio-running-forever" class="headerlink" title="Keeping verdaccio running forever"></a>Keeping verdaccio running forever</h3><p>You can use node package called <a href="https://github.com/nodejitsu/forever" target="_blank" rel="noopener">&#39;forever&#39;</a> to keep <code>verdaccio</code> running all the time.</p>
<p>First install <code>forever</code> globally:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g forever</span><br></pre></td></tr></table></figure>
<p>Make sure you&#39;ve run <code>verdaccio</code> at least once to generate the config file and write down the created admin user. You can then use the following command to start <code>verdaccio</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ forever start `which verdaccio`</span><br></pre></td></tr></table></figure>
<p>You can check the documentation for more information on how to use forever.</p>
<p>Surviving server restarts</p>
<p>You can use <code>crontab</code> and <code>forever</code> together to start <code>verdaccio</code> after a server reboot. When you&#39;re logged in as the <code>verdaccio</code> user do the following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ crontab -e</span><br></pre></td></tr></table></figure>
<p>This might ask you to choose an editor. Pick your favorite and proceed. Add the following entry to the file:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@reboot /usr/bin/forever start /usr/lib/node_modules/verdaccio/bin/verdaccio</span><br></pre></td></tr></table></figure>
<p>The locations may vary depending on your server setup. If you want to know where your files are you can use the &#39;which&#39; command:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ which forever</span><br><span class="line">$ which verdaccio</span><br></pre></td></tr></table></figure>
<h3 id="本地配置-registry"><a href="#本地配置-registry" class="headerlink" title="本地配置 registry"></a>本地配置 registry</h3><p>推荐安装 <a href="https://bitbucket.org/jogiterding/mypro/src/3cc4c7f5f15f3817af3882bdf532aeacc4f660e2/%5Bhttps:/github.com/Pana/nrm%5D(https:/github.com/Pana/nrm" target="_blank" rel="noopener">nrm</a>) 来管理 registry</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g nrm</span><br><span class="line">$ nrm add knpm http://concierge11.klook.io/verdaccio/</span><br><span class="line">$ nrm use knpm</span><br></pre></td></tr></table></figure>
<h3 id="发布和安装私有包"><a href="#发布和安装私有包" class="headerlink" title="发布和安装私有包"></a>发布和安装私有包</h3><blockquote>
<p>发布私有包时，强烈建议修改 <code>package.json</code> 中的包名，带上 scope <code>@klook</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改包名 @klook/utils</span><br><span class="line">$ npm publish </span><br><span class="line">$ npm install @vue/cli</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="使用-cnpmjs-org"><a href="#使用-cnpmjs-org" class="headerlink" title="使用 cnpmjs.org"></a>使用 <code>cnpmjs.org</code></h2><p><a href="https://github.com/cnpm/cnpmjs.org" target="_blank" rel="noopener">cnpmjs.org</a>: Private npm registry and web for Enterprise, base on <a href="http://koajs.com/" target="_blank" rel="noopener">koa</a>, MySQL and <a href="https://github.com/cnpm/cnpmjs.org/wiki/NFS-Guide" target="_blank" rel="noopener">Simple Store Service</a>.</p>
<h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><ul>
<li>Node &gt;= 6.11.3</li>
<li>MySQL &gt;= 0.5.0, include <code>mysqld</code> and <code>mysql</code> cli</li>
<li><a href="https://bitbucket.org/jogiterding/mypro/src/3cc4c7f5f15f3817af3882bdf532aeacc4f660e2/%5Bhttps:/github.com/cnpm/cnpmjs.org/wiki/NFS-Guide%5D(https:/github.com/cnpm/cnpmjs.org/wiki/NFS-Guide" target="_blank" rel="noopener">Simple File Store Service, like qiniu, aliyun-oss, tfs, upyun</a>)</li>
</ul>
<h3 id="Install-1"><a href="#Install-1" class="headerlink" title="Install"></a>Install</h3><ol>
<li>Get the Code</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># clone from github</span><br><span class="line">$ git clone git://github.com/cnpm/cnpmjs.org.git $HOME/cnpmjs.org</span><br><span class="line">$ cd $HOME/cnpmjs.org</span><br></pre></td></tr></table></figure>
<p>Install <code>cnpmjs.org</code> and <code>cnpm</code> from npm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g --build-from-source cnpmjs.org cnpm sqlite3</span><br></pre></td></tr></table></figure>
<p>If you&#39;re in China, maybe you should use China mirror</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g --build-from-source \</span><br><span class="line">  --registry=https://registry.npm.taobao.org \</span><br><span class="line">  --disturl=https://npm.taobao.org/mirrors/node \</span><br><span class="line">  cnpmjs.org cnpm sqlite3</span><br></pre></td></tr></table></figure>
<ol>
<li><code>mysql</code> 数据库操作：</li>
</ol>
<p>a. 创建数据库 <code>klook-npm</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database klook-npm</span><br></pre></td></tr></table></figure>
<p>b. 创建表：<a href="https://github.com/cnpm/cnpmjs.org/blob/master/docs/db.sql" target="_blank" rel="noopener">Get all the sqls here</a></p>
<p><a href="http://www.ifepoland.com/lilip/p/10109557.html" target="_blank" rel="noopener">mysql 8.0 创建 table 时报错:【MYSQL】MYSQL报错解决方法： Warning: (3719, &quot;&#39;utf8&#39; is currently an alias for the character set UTF8MB3, but will be an alias for UTF8M B4 in a future release.&quot;</a></p>
<p><a href="[https://img.jogiter.cn//tech/db%28mysql8.0%29.sql](https://img.jogiter.cn//tech/db%28mysql8.0%29.sql">点击下载修复版 SQL</a></p>
<ol>
<li>Edit Your Own Config File</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd $HOME/cnpmjs.org</span><br><span class="line">$ vim config/index.js</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  debug: false,</span><br><span class="line">  enableCluster: true, // enable cluster mode</span><br><span class="line">  enablePrivate: true, // enable private mode, only admin can publish, other use just can sync package from source npm</span><br><span class="line">  database: &#123;</span><br><span class="line">      db: &apos;klook-npm&apos;,</span><br><span class="line">      username: &apos;root&apos;,</span><br><span class="line">      password: &apos;password&apos;,</span><br><span class="line"></span><br><span class="line">      // the sql dialect of the database</span><br><span class="line">      // - currently supported: &apos;mysql&apos;, &apos;sqlite&apos;, &apos;postgres&apos;, &apos;mariadb&apos;</span><br><span class="line">      dialect: &apos;mysql&apos;,</span><br><span class="line"></span><br><span class="line">      // custom host; default: 127.0.0.1</span><br><span class="line">      host: &apos;l-testing-contains-main-56.cbw4mscvt9bw.ap-southeast-1.rds.amazonaws.com&apos;,</span><br><span class="line"></span><br><span class="line">      // custom port; default: 3306</span><br><span class="line">      port: 3306,</span><br><span class="line"></span><br><span class="line">      ssl: &#123;</span><br><span class="line">          ca: path.join(dataDir, &apos;certs/mysql-test.pem&apos;)</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // use pooling in order to reduce db connection overload and to increase speed</span><br><span class="line">      // currently only for mysql and postgresql (since v1.5.0)</span><br><span class="line">      pool: &#123;</span><br><span class="line">        maxConnections: 10,</span><br><span class="line">        minConnections: 0,</span><br><span class="line">        maxIdleTime: 30000</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      dialectOptions: &#123;</span><br><span class="line">        trace: true,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // the storage engine for &apos;sqlite&apos;</span><br><span class="line">      // default store into ~/.cnpmjs.org/data.sqlite</span><br><span class="line">      storage: path.join(dataDir, &apos;data.sqlite&apos;),</span><br><span class="line"></span><br><span class="line">      logging: !!process.env.SQL_DEBUG,</span><br><span class="line">  &#125;,</span><br><span class="line">  admins: &#123;</span><br><span class="line">    admin: &apos;admin@cnpmjs.org&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  // registry scopes, if don&apos;t set, means do not support scopes</span><br><span class="line">  scopes: [ &apos;@knpm&apos;, &apos;@knpmtest&apos;, &apos;@knpm-test&apos; ],</span><br><span class="line">  // &apos;none&apos;: 永不同步，只管理私有用户上传的包，其它源包会直接从源站获取</span><br><span class="line">  // &apos;exist&apos;: 定时同步已经存在于数据库的包</span><br><span class="line">  // &apos;all&apos;: 定时同步所有源站的</span><br><span class="line">  syncModel: &apos;none&apos;// &apos;none&apos;, &apos;all&apos;, &apos;exist&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意这里的 <code>mysql</code> 的连接使用测试环境的 <code>mysql</code>，采用 <code>ssl</code> 的方式进行连接，因此还需要添加 <code>ssl</code> 配置。</p>
<p>详细配置参考<a href="https://medoc.000webhostapp.com/2018/04/19/npm%E7%A7%81%E5%BA%93%E6%90%AD%E5%BB%BA-cnpm-js/" target="_blank" rel="noopener">配置字段参考</a></p>
<ol>
<li>添加 <code>ssl</code> 文件，同时将 <code>key</code> 内容拷贝到 <code>~/.cnpmjs.org/certs/mysql-test.pem</code> 文件。具体的 <code>key</code> 请咨询测试同事。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~/.cnpmjs.org/</span><br><span class="line">$ mkdir certs</span><br><span class="line">$ touch mysql-test.pem</span><br></pre></td></tr></table></figure>
<ul>
<li><code>~/.cnpmjs.org/nfs</code> ：默认储存发布和缓存的包，可设置不缓存下载的包。具体请参考配置参考。</li>
</ul>
<ol>
<li>开启服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~/cnpmjs.org/</span><br><span class="line">$ npm run start</span><br></pre></td></tr></table></figure>
<p><code>registry</code>：<a href="http://localhost:7001/" target="_blank" rel="noopener">http://localhost:7001</a>  <code>web</code>：<a href="http://localhost:7002/" target="_blank" rel="noopener">http://localhost:7002</a></p>
<p>配置 <code>Nginx</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd /etc/nginx/</span><br><span class="line">$ vim nginx.conf</span><br></pre></td></tr></table></figure>
<p><code>Nginx</code> 设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  concierge11.klook.io;</span><br><span class="line"></span><br><span class="line">  location ~ ^/knpm/(.*)$ &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:7001/$1;</span><br><span class="line">    proxy_set_header Host            $host:$server_port;</span><br><span class="line">    proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">  &#125;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:7002/;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header Host  $http_host;</span><br><span class="line">    proxy_set_header X-Nginx-Proxy true;</span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_set_header Connection &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>本地环境设置 <code>registry</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cnpm set registry http://concierge11.klook.io/knpm/</span><br></pre></td></tr></table></figure>
<p>发布和安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cnpm login</span><br><span class="line">$ cnpm publish</span><br><span class="line">$ cnpm install</span><br></pre></td></tr></table></figure>
<ol>
<li>个性化配置 <code>npm</code> ，详细请阅读项目源码~</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~/cnpmjs.org/</span><br></pre></td></tr></table></figure>
<h2 id="difference"><a href="#difference" class="headerlink" title="difference"></a>difference</h2><ul>
<li>verdaccio<ul>
<li>安装简单，不需要数据库支持</li>
<li>设置 <code>registry</code> 后通过 <code>npm</code> 来进行包管理</li>
<li>可配置性低；服务器会储存所有的包，包括发布的私语包和下载的包</li>
<li>定制化页面需要修改全局安装的源码</li>
</ul>
</li>
<li>cnpmjs.org<ul>
<li>安装复杂，需要安装 <code>mysql</code></li>
<li>设置 <code>registry</code> 后通过 <code>cnpm</code> 来进行包管理</li>
<li>高度可配置；支持服务器只存储发布的私有包</li>
<li>定制化页面需要修改部署安装的源码</li>
</ul>
</li>
</ul>
<h2 id="Readings"><a href="#Readings" class="headerlink" title="Readings"></a>Readings</h2><ul>
<li><a href="https://verdaccio.org/docs/en/installation" target="_blank" rel="noopener">verdaccio 安装</a></li>
<li><a href="https://github.com/cnpm/cnpmjs.org/wiki/Deploy-a-private-npm-registry-in-5-minutes" target="_blank" rel="noopener">Deploy a private npm registry in 5 minutes</a></li>
<li><a href="https://github.com/jaywcjlove/handbook/blob/master/CentOS/%E5%9C%A85%E5%88%86%E9%92%9F%E5%86%85%E6%90%AD%E5%BB%BA%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E7%A7%81%E6%9C%89npm%E4%BB%93%E5%BA%93.md" target="_blank" rel="noopener">在5分钟内搭建企业内部私有npm仓库</a></li>
</ul>
]]></content>
      <categories>
        <category>TOOLS</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 3.7+新特性</title>
    <url>/chayaBlog/2020/05/08/ts/TypeScript3.7+%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p><a href="https://www.typescriptlang.org/play/?ts=3.6.3#" target="_blank" rel="noopener">ts-playground</a></p>
<h3 id="可选链（V3-7）"><a href="#可选链（V3-7）" class="headerlink" title="可选链（V3.7）"></a><strong>可选链（V3.7）</strong></h3><p>可选链可以让我们的 TypeScript 代码可以在遇到null或undefined的时候立即停止当前的操作，转而运行之后的代码.</p>
<p>// v3.7以前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const data: any = &#123;&#125;</span><br><span class="line">if (data &amp;&amp; data.customer &amp;&amp; data.customer.address) &#123;</span><br><span class="line">   const &#123;address&#125; = data.customer</span><br><span class="line">   const fullAddress = `$&#123;address.street&#125;, $&#123;address.city&#125;, $&#123;address.state&#125;$&#123;address.zipcode&#125;`</span><br><span class="line">   console.log(fullAddress)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// v3.7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// data access</span><br><span class="line">const data: any = &#123;&#125;</span><br><span class="line">const address = data?.customer?.address</span><br><span class="line">const fullAddress = `$&#123;address?.street&#125;, $&#123;address?.city&#125;, $&#123;address?.state&#125; $&#123;address?.zipcode&#125;`</span><br><span class="line">console.log(fullAddress)</span><br></pre></td></tr></table></figure>
<p>// 也适用于数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const customers: any[] = []</span><br><span class="line">customers?.[0]?.[&apos;address&apos;]</span><br></pre></td></tr></table></figure>
<p>// 检查方法是否已定义并调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const customer: any = &#123;&#125;</span><br><span class="line">customer.approve?.()</span><br></pre></td></tr></table></figure>
<h3 id="空值合并（V3-7）"><a href="#空值合并（V3-7）" class="headerlink" title="空值合并（V3.7）"></a><strong>空值合并（V3.7）</strong></h3><p>空值合并运算符是 || 的替代方法，如果左侧是 null 或 undefined，则它返回右侧的表达式。这和 || 有什么不同？</p>
<p>|| 本质上是 JavaScript 中的布尔 OR 运算符，我们尝试利用短路返回第一个非 false 值。这可能会产生意想不到的结果，因为当要求数字 0 或空字符串作为有效输入时，将会被视为 false。让我们用一个例子来说明：</p>
<p>// 以前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">    inputString: &apos;&apos;,</span><br><span class="line">    number: 0,</span><br><span class="line">    rememberFlag: false</span><br><span class="line">&#125;</span><br><span class="line">passPhrase = data.inputString || &apos;Unknown&apos;  //不会接受 &quot;&quot; (空字符串)</span><br><span class="line">passCode =  data.number || &apos;-1111&apos; // 不会接受 0</span><br><span class="line">rememberMe = data.rememberFlag || true // 将会总是 true!!!</span><br></pre></td></tr></table></figure>
<p>// 现在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">    inputString: &apos;&apos;,</span><br><span class="line">    number: 0,</span><br><span class="line">    rememberFlag: false</span><br><span class="line">&#125;</span><br><span class="line">let passPhrase = data.inputString ?? &apos;Unknown&apos;  //仅在 inputString 未定义时为 Unknown</span><br><span class="line">let passCode =  data.number ?? &apos;-1111&apos; // 0 可以通过</span><br><span class="line">let rememberMe = data.rememberFlag ?? true // false 是有效值</span><br><span class="line">console.log(passPhrase, passCode, rememberMe)</span><br><span class="line">// 通过这种方式可以明确地区分 undefined 与 false 的值。</span><br></pre></td></tr></table></figure>
<h3 id="递归类型别名（V3-7）"><a href="#递归类型别名（V3-7）" class="headerlink" title="递归类型别名（V3.7）"></a><strong>递归类型别名（V3.7）</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Json =</span><br><span class="line">    | string</span><br><span class="line">    | number</span><br><span class="line">    | boolean</span><br><span class="line">    | null</span><br><span class="line">    | &#123; [property: string]: Json &#125;</span><br><span class="line">    | Json[];</span><br></pre></td></tr></table></figure>
<p>// 3.7之前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Json = | string | number | boolean | null | JsonObject | JsonArray; </span><br><span class="line">interface JsonObject &#123; [property: string]: Json; &#125; </span><br><span class="line">interface JsonArray extends Array&lt;Json&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="断言函数（V3-7）"><a href="#断言函数（V3-7）" class="headerlink" title="断言函数（V3.7）"></a><strong>断言函数（V3.7）</strong></h3><p>它们是一些特殊函数的集合。当一些非预期的事情发生的时候它们将抛出 error。它们被称为断言函数。例如，Node.js 为此有一个专门的函数assert。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert(someValue === 42);</span><br></pre></td></tr></table></figure>
<p>在此示例中，如果someValue不等于42，assert则将抛出AssertionError。</p>
<p>JavaScript中的断言通常用于防止传入不正确的类型。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function multiply(x, y) &#123;</span><br><span class="line">    assert(typeof x === &quot;number&quot;);</span><br><span class="line">    assert(typeof y === &quot;number&quot;);</span><br><span class="line"></span><br><span class="line">    return x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不太好的是，在TypeScript中，这些检查永远无法正确编码。对于松散类型的代码，这意味着TypeScript的检查较少，而对于稍微保守的代码，则通常迫使用户使用类型断言。</p>
<p>这里有可供选择的替代写法，可以让 TypeScript 分析出问题，不过并不方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function yell(str) &#123;</span><br><span class="line">  if (typeof str !== &apos;string&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;str should have been a string.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  // Error caught!</span><br><span class="line">  return str.toUppercase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TypeScript 3.7 引入了一个「断言签名（assertion signatures）」的新概念，用来模拟这些断言函数。</p>
<p>第一种断言签名，模拟 Node 中的 assert 函数的功能。它确保在断言的范围内，断言条件必须为这个真。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function assert(condition: any, msg?: string): asserts condition &#123;</span><br><span class="line">    if (!condition) &#123;</span><br><span class="line">        throw new AssertionError(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>asserts condition</code> 的意思是，如果 assert 函数有返回，传入 condition 的参数必须为真，因为如果不是这样，它肯定会抛出一个错误。这意味着，在剩下的作用域中（if 条件后）condition 必须为 truthy。</p>
<p>举一个例子，用这个断言函数意味着我们可以实现捕获之前的 yell 示例的错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function yell(str) &#123;</span><br><span class="line">    assert(typeof str === &quot;string&quot;);</span><br><span class="line"></span><br><span class="line">    return str.toUppercase();</span><br><span class="line">    //         ~~~~~~~~~~~</span><br><span class="line">    // error: Property &apos;toUppercase&apos; does not exist on type &apos;string&apos;.</span><br><span class="line">    //        Did you mean &apos;toUpperCase&apos;?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function assert(condition: any, msg?: string): asserts condition &#123;</span><br><span class="line">    if (!condition) &#123;</span><br><span class="line">        throw new AssertionError(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种断言签名不是用来校验一个条件，而是告诉 TypeScript 某个变量或属性有不同的类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这里 `asserts val is string` 确保在 `assertIsString` 在被调用之后, 任何传入的变量将被认为是一个 `string`.</span><br><span class="line">function assertIsString(val: any): asserts val is string &#123;</span><br><span class="line">    if (typeof val !== &quot;string&quot;) &#123;</span><br><span class="line">        throw new AssertionError(&quot;Not a string!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function yell(str: any) &#123;</span><br><span class="line">  assertIsString(str);</span><br><span class="line">  // Now TypeScript knows that &apos;str&apos; is a &apos;string&apos;.</span><br><span class="line"></span><br><span class="line">  return str.toUppercase();</span><br><span class="line">  //         ~~~~~~~~~~~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="未调用函数检查（V3-7）"><a href="#未调用函数检查（V3-7）" class="headerlink" title="未调用函数检查（V3.7）"></a><strong>未调用函数检查（V3.7）</strong></h3><p>一个常见且危险的错误是忘记调用一个函数，特别是当函数具有零参数或用暗示它可能是属性而不是函数的方式名称时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> interface User &#123;</span><br><span class="line">    isAdministrator(): boolean;</span><br><span class="line">    notify(): void;</span><br><span class="line">    doNotDisturb?(): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doAdminThing(user: User) &#123;</span><br><span class="line">    if (user.isAdministrator) &#123;</span><br><span class="line">        // sudo();</span><br><span class="line">        // editTheConfiguration();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new Error(&quot;User is not an admin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="仅仅导入-导出声明-（v3-8"><a href="#仅仅导入-导出声明-（v3-8" class="headerlink" title="仅仅导入/导出声明 （v3.8)"></a><strong>仅仅导入/导出声明 （v3.8)</strong></h3><p>为了能让我们导入类型，TypeScript 重用了 JavaScript 导入语法。例如在下面的这个例子中，我们确保 JavaScript 的值 doThing 以及 TypeScript 类型 Options 一同被导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ./foo.ts</span><br><span class="line">interface Options &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function doThing(options: Options) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ./bar.ts</span><br><span class="line">import &#123; doThing, Options &#125; from &apos;./foo.js&apos;;</span><br><span class="line"></span><br><span class="line">function doThingBetter(options: Options) &#123;</span><br><span class="line">  // do something twice as good</span><br><span class="line">  doThing(options);</span><br><span class="line">  doThing(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这仅是因为一个被称之为「导入省略」的功能而起作用。当 TypeScript 输出一个 JavaScript 文件时，TypeScript 会识别出 <code>Options</code> 仅仅是当作了一个类型来使用，它将会删除 <code>Options</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ./foo.js</span><br><span class="line">export function doThing(options) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ./bar.js</span><br><span class="line">import &#123; doThing &#125; from &apos;./foo.js&apos;;</span><br><span class="line"></span><br><span class="line">function doThingBetter(options) &#123;</span><br><span class="line">  // do something twice as good</span><br><span class="line">  doThing(options);</span><br><span class="line">  doThing(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在通常情况下，这种行为都是比较好的。但是它会导致一些其他问题。在一些场景下，TypeScript 会混淆导出的究竟是一个类型还是一个值。比如在下面的例子中， 我们根本无法确定 <strong>MyThing</strong> 是否是一个类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; MyThing &#125; from &apos;./some-module.js&apos;;</span><br><span class="line">export &#123; MyThing &#125;;</span><br></pre></td></tr></table></figure>
<p>为了避免出现类似情况, TypeScript 3.8为仅类型导入和导出添加了新语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import type &#123; SomeThing &#125; from &quot;./some-module.js&quot;;</span><br><span class="line">export type &#123; SomeThing &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>import type</strong> 仅仅导入被用于类型注解或声明的声明语句，它总是会被完全删除，因此在运行时将不会留下任何代码。与此相似，<strong>export type</strong> 仅仅提供一个用于类型的导出，在 TypeScript 输出文件中，它也将会被删除。</p>
<h3 id="ECMAScript-提案的私有字段-v3-8"><a href="#ECMAScript-提案的私有字段-v3-8" class="headerlink" title="ECMAScript 提案的私有字段 (v3.8)"></a><strong>ECMAScript 提案的私有字段 (v3.8)</strong></h3><p>TypeScript 3.8 支持在 ECMAScript 中处于 <a href="https://github.com/tc39/proposal-class-fields/" target="_blank" rel="noopener">stage-3</a> 中的私有字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    #name: string</span><br><span class="line"></span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.#name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    greet() &#123;</span><br><span class="line">        console.log(`Hello, my name is $&#123;this.#name&#125;!`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jeremy = new Person(&quot;Jeremy Bearimy&quot;);</span><br><span class="line"></span><br><span class="line">jeremy.#name</span><br><span class="line">//     ~~~~~</span><br><span class="line">// Property &apos;#name&apos; is not accessible outside class &apos;Person&apos;</span><br><span class="line">// because it has a private identifier.</span><br></pre></td></tr></table></figure>
<p>和常规属性(这里特别比较 private 修饰符声明的比较)不同，私有字段(private fields)拥有下面这些特性。</p>
<ul>
<li>私有字段使用 # 字符做为开始，通常，我们也把这些称为私有名称。</li>
<li>每个私有字段的名字，在被包含的类中，都是唯一的</li>
<li>在 TypeScript 中，像 public 和 private 修饰符不能用于私有字段</li>
<li>私有字段不能在所包含的类之外访问 —— 即使是对于 JavaScript 使用者来说也是如此。通常，我们把这种称为强隐私「hard privacy」。</li>
</ul>
<p><strong>除了能保存自己的私有这一属性以外，私有字段的另一个好处是我们刚才提到的唯一性。例如，常规属性声明易于在子类中被覆盖。而 private fields 是受保护的。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    foo = 10;</span><br><span class="line"></span><br><span class="line">    cHelper() &#123;</span><br><span class="line">        return this.foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D extends C &#123;</span><br><span class="line">    foo = 20;</span><br><span class="line"></span><br><span class="line">    dHelper() &#123;</span><br><span class="line">        return this.foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance = new D();</span><br><span class="line">// &apos;this.foo&apos; refers to the same property on each instance.</span><br><span class="line">console.log(instance.cHelper()); // prints &apos;20&apos;</span><br><span class="line">console.log(instance.dHelper()); // prints &apos;20&apos;</span><br></pre></td></tr></table></figure>
<p>使用私有字段时，你完全不必对此担心，因为每个私有字段，在所包含的类中，都是唯一的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    #foo = 10;</span><br><span class="line"></span><br><span class="line">    cHelper() &#123;</span><br><span class="line">        return this.#foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D extends C &#123;</span><br><span class="line">    #foo = 20;</span><br><span class="line"></span><br><span class="line">    dHelper() &#123;</span><br><span class="line">        return this.#foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance = new D();</span><br><span class="line">// &apos;this.#foo&apos; refers to a different field within each class.</span><br><span class="line">console.log(instance.cHelper()); // prints &apos;10&apos;</span><br><span class="line">console.log(instance.dHelper()); // prints &apos;20&apos;</span><br></pre></td></tr></table></figure>
<p>另外有一个值得注意的地方，访问一个有其他类型的私有字段，都将导致 TypeError。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Square &#123;</span><br><span class="line">    #sideLength: number;</span><br><span class="line"></span><br><span class="line">    constructor(sideLength: number) &#123;</span><br><span class="line">        this.#sideLength = sideLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    equals(other: any) &#123;</span><br><span class="line">        return this.#sideLength === other.#sideLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const a = new Square(100);</span><br><span class="line">const b = &#123; sideLength: 100 &#125;;</span><br><span class="line"></span><br><span class="line">// Boom!</span><br><span class="line">// TypeError: attempted to get private field on non-instance</span><br><span class="line">// This fails because &apos;b&apos; is not an instance of &apos;Square&apos;.</span><br><span class="line">console.log(a.equals(b));</span><br></pre></td></tr></table></figure>
<p>该使用哪个</p>
<p>在属性方面，TypeScript private 修饰符在编译后将会被删除 —— 因此，尽管有数据存在，但是在输出的 JavaScript 代码中没有关于该属性声明的任何编码。当涉及到属性时，TypeScript的private修饰符会并没有完全正确的执行，它的行为完全像普通属性一样，并且没有办法告诉它是使用private 修饰符并没有完全的生效。我们称之为 soft privacy, 我们依然可以通过 [&#39;foo&#39;] 这样的形式访问到。看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    private foo = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is an error at compile time,</span><br><span class="line">// but when TypeScript outputs .js files,</span><br><span class="line">// it&apos;ll run fine and print &apos;10&apos;.</span><br><span class="line">console.log(new C().foo);    // prints &apos;10&apos;</span><br><span class="line">//                  ~~~</span><br><span class="line">// error! Property &apos;foo&apos; is private and only accessible within class &apos;C&apos;.</span><br><span class="line"></span><br><span class="line">// TypeScript allows this at compile-time</span><br><span class="line">// as a &quot;work-around&quot; to avoid the error.</span><br><span class="line">console.log(new C()[&quot;foo&quot;]); // prints &apos;10&apos;</span><br></pre></td></tr></table></figure>
<p>对比下面使用 # 私有字段，是完全访问不到的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    #foo = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new C().#foo); // SyntaxError</span><br><span class="line">//                  ~~~~</span><br><span class="line">// TypeScript reports an error *and*</span><br><span class="line">// this won&apos;t work at runtime!</span><br><span class="line"></span><br><span class="line">console.log(new C()[&quot;#foo&quot;]); // prints undefined</span><br><span class="line">//          ~~~~~~~~~~~~~~~</span><br><span class="line">// TypeScript reports an error under &apos;noImplicitAny&apos;,</span><br><span class="line">// and this prints &apos;undefined&apos;.</span><br></pre></td></tr></table></figure>
<p><strong>TypeScript 只有在编译目标为 ECMAScript 2015（ES6）及其以上时，才能支持该私有字段，TypeScript 的 private 声明属性能在所有的编译目标下正常工作 —— 甚至是 ECMAScript 3。</strong></p>
<h3 id="export-as-ns-语法使用"><a href="#export-as-ns-语法使用" class="headerlink" title="export * as ns 语法使用"></a><strong>export * as ns 语法使用</strong></h3><p>通常有一个入口点将另一个模块的所有成员集中并公开为一个变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as utilities from &quot;./utilities.js&quot;;</span><br><span class="line">export &#123; utilities &#125;;</span><br></pre></td></tr></table></figure>
<p>这很普遍，以至于ECMAScript 2020添加了新语法来支持这种模式！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export * as utilities from &quot;./utilities.js&quot;;</span><br></pre></td></tr></table></figure>
<p>TypeScript 3.8实现了此语法。当模块目标早于es2020时，TypeScript将按照第一个代码段的内容输出内容。</p>
<h3 id="顶层-await-使用"><a href="#顶层-await-使用" class="headerlink" title="顶层 await 使用"></a><strong>顶层 await 使用</strong></h3><p><a href="https://es6.ruanyifeng.com/#docs/async#%E9%A1%B6%E5%B1%82-await" target="_blank" rel="noopener">顶层await</a></p>
<p>通常我们使用 JavaScript 常会引入一个async 函数来使用 await.</p>
<p>在 JavaScript中（以及其他大多数具有类似功能的语言）await 仅在 async 函数体内被允许。但是，对于 top await，我们可以 await 在模块的顶层使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function main() &#123;</span><br><span class="line">    const response = await fetch(&quot;...&quot;);</span><br><span class="line">    const greeting = await response.text();</span><br><span class="line">    console.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">    .catch(e =&gt; console.error(e))</span><br><span class="line">const response = await fetch(&quot;...&quot;);</span><br><span class="line">const greeting = await response.text();</span><br><span class="line">console.log(greeting);</span><br><span class="line"></span><br><span class="line">// Make sure we&apos;re a module</span><br><span class="line">export &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><code>仅当目标编译器选项为es2017或更高版本时，才可以使用顶级await</code></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><strong>参考文档</strong></h2><p><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/" target="_blank" rel="noopener">Announcing TypeScript 3.7</a></p>
<p><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-8/" target="_blank" rel="noopener">Announcing TypeScript 3.8</a></p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 用法总结</title>
    <url>/chayaBlog/2019/09/15/ts/TypeScript%E7%94%A8%E6%B3%95%20/</url>
    <content><![CDATA[<h3 id="TypeScript-用法总结"><a href="#TypeScript-用法总结" class="headerlink" title="TypeScript 用法总结"></a>TypeScript 用法总结</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 范型</span></span><br><span class="line"><span class="keyword">interface</span> Response&lt;T&gt; &#123;</span><br><span class="line">  success: <span class="built_in">boolean</span>;</span><br><span class="line">  error: &#123;</span><br><span class="line">    code: <span class="built_in">string</span>;</span><br><span class="line">    message: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  result: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ResponseA = Response&lt;&#123; name: <span class="built_in">string</span> &#125;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> responseA: ResponseA = &#123;</span><br><span class="line">  success: <span class="literal">true</span>,</span><br><span class="line">  error: &#123;</span><br><span class="line">    <span class="string">'code'</span>: <span class="string">''</span>,</span><br><span class="line">    <span class="string">'message'</span>: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  result: &#123;</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> responseB: Response&lt;&#123; age: <span class="built_in">number</span> &#125;&gt; = &#123;</span><br><span class="line">  success: <span class="literal">true</span>,</span><br><span class="line">  error: &#123;</span><br><span class="line">    <span class="string">'code'</span>: <span class="string">''</span>,</span><br><span class="line">    <span class="string">'message'</span>: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  result: &#123;</span><br><span class="line">    age: <span class="number">111</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise 和 范型</span></span><br><span class="line"><span class="keyword">const</span> promiseA: <span class="built_in">Promise</span>&lt;ResponseA&gt; = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(responseA);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promiseA.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// value.result.name;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TS 定义一个数组和对象 ( | &amp;&amp; &amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TypeA = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">const</span> arrayA: TypeA[]= [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arrayB: <span class="built_in">Array</span>&lt;TypeA&gt;= [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mixIn = &lt;T, N&gt;(a: T, b: N): T &amp; <span class="function"><span class="params">N</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectA = &#123;name: <span class="string">'A'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectB = &#123;age: <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectMixIn = mixIn(objectA, objectB);</span><br><span class="line"><span class="comment">// objectMixIn.age;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ? &amp;&amp; !</span></span><br><span class="line"><span class="keyword">interface</span> TestA &#123;</span><br><span class="line">  config?: &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testA: TestA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testA.config.name;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (testA.config) &#123;</span><br><span class="line">  testA.config.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testA.config!.name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  定义字典</span></span><br><span class="line"><span class="keyword">const</span> objectMap: ObjectMap = &#123;</span><br><span class="line">  <span class="string">'HKD'</span>: <span class="string">'港币'</span>,</span><br><span class="line">  <span class="string">'USD'</span>: <span class="string">'美元'</span>,</span><br><span class="line">  <span class="string">'TWD'</span>: <span class="string">'台币'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ObjectMap &#123;</span><br><span class="line">  [currencyCode: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载 （有返回值）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">param: <span class="built_in">string</span></span>): </span>&#123; name: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">param: <span class="built_in">number</span></span>): </span>&#123; age: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arg === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: arg</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arg === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      age: arg</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getInfo(<span class="string">'A'</span>).name;</span><br><span class="line"></span><br><span class="line">getInfo(<span class="number">10</span>).age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数重载复杂例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> EventName &#123;</span><br><span class="line">  getNumber = <span class="string">'getNumber'</span>,</span><br><span class="line">  getString = <span class="string">'getString'</span>,</span><br><span class="line">  getString1 = <span class="string">'getString'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> EventEmit &#123;</span><br><span class="line">  (eventName: EventName.getNumber, params: <span class="built_in">number</span>): <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line">  (eventName: EventName.getString, params: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">  (eventName: EventName.getString, params: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> EventOn &#123;</span><br><span class="line">  (eventName: EventName.getNumber, callback: <span class="function">(<span class="params">params: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line">  (eventName: EventName.getString, callback: <span class="function">(<span class="params">params: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span></span><br><span class="line">  (eventName: EventName.getString, callback: <span class="function">(<span class="params">params: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> EventBus &#123;</span><br><span class="line">  emit: EventEmit;</span><br><span class="line">  on: EventOn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'Vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventBus: EventBus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line">eventBus.emit(EventName.getString, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">eventBus.emit(EventName.getNumber, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">eventBus.on(EventName.getString, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射类型</span></span><br><span class="line"><span class="keyword">interface</span> EventMaps &#123;</span><br><span class="line">  getNumber: <span class="built_in">number</span></span><br><span class="line">  getString: <span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> EventEmitT &#123;</span><br><span class="line">  &lt;T <span class="keyword">extends</span> keyof EventMaps&gt;(eventName: T, params: EventMaps[T]): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> EventOnT &#123;</span><br><span class="line">  &lt;T <span class="keyword">extends</span> keyof EventMaps&gt;<span class="function">(<span class="params">eventName: T, callback: (<span class="params">params: EventMaps[T]</span>) =&gt; <span class="built_in">void</span></span>): <span class="params">void</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">interface</span> <span class="params">EventBusB</span> &#123;</span></span><br><span class="line"><span class="function">  <span class="params">emit</span>: <span class="params">EventEmitT</span></span></span><br><span class="line"><span class="function">  <span class="params">on</span>: <span class="params">EventOnT</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">eventBusB</span>: <span class="params">EventBusB</span> = <span class="params">new</span> <span class="params">Vue</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">eventBusB</span>.<span class="params">emit</span>(<span class="params">EventName.getString, 'test'</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">eventBusB</span>.<span class="params">on</span>(<span class="params">EventName.getString, (<span class="params">res</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">console</span>.log(<span class="params">res</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>);</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>typescript函数重载</title>
    <url>/chayaBlog/2018/11/15/ts/Typescript%E5%87%BD%E6%95%B0%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>在使用ts中我们经常会需定义函数的接口，例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">interface GetParam &#123;</span><br><span class="line">(key:string):string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getParam:GetParam = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> config = &#123;</span><br><span class="line">        config1:<span class="string">'config1'</span>,</span><br><span class="line">        config2:<span class="string">'config2'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> config[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但有时候我们需要我们的方法，根据我们传入的参数，来返回不同的类型,例如我们可以这样子</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> GetParam &#123;</span><br><span class="line">  (key:<span class="built_in">string</span>|<span class="built_in">string</span>[]):<span class="built_in">string</span>|<span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getParam:GetParam = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> config = &#123;</span><br><span class="line">    config1:<span class="string">'config1'</span>,</span><br><span class="line">    config2:<span class="string">'config2'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> config[key];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result:<span class="built_in">string</span>[] = [];</span><br><span class="line">    key.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      result.push(config[item]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写会存在一个问题，就是我们在使用这个方法的时候，我们是明确知道传入字符串的时候返回的是字符串，传入数组的时候返回的是数组。<br>但是这样写接口我们调用的时候ide并不能准确的帮我们识别类型。我们可能需要这样去调用方法才能让ide做类型推断。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> config1 = getParam(<span class="string">'config1'</span>) <span class="keyword">as</span> <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
<p>为了应对这种情况，我们可以使用ts 的函数重载，虽然这不是正真意义上的重载，但是能够帮助ide更好的去做类型推断。</p>
<p>我们只需要把接口改成这样就可以了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> GetParam &#123;</span><br><span class="line">  (key:<span class="built_in">string</span>):<span class="built_in">string</span>;</span><br><span class="line">  (keys:<span class="built_in">string</span>[]):<span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getParam:GetParam = <span class="function"><span class="keyword">function</span>(<span class="params">key:<span class="built_in">string</span>|<span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> config = &#123;</span><br><span class="line">    config1:<span class="string">'config1'</span>,</span><br><span class="line">    config2:<span class="string">'config2'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> config[key];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result:<span class="built_in">string</span>[] = [];</span><br><span class="line">    key.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      result.push(config[item]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config1 = getParam(<span class="string">'config1'</span>);</span><br></pre></td></tr></table></figure>
<p>这样当我们传入参数为字符串的时候，ide就能自动的帮我们推断出返回的值是字符串。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript 用法总结</title>
    <url>/chayaBlog/2019/08/23/ts/interface_VS_type/</url>
    <content><![CDATA[<h3 id="interface-VS-type"><a href="#interface-VS-type" class="headerlink" title="interface VS type"></a>interface VS type</h3><h5 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h5><ul>
<li><h5 id="都可以描述一个对象或者函数"><a href="#都可以描述一个对象或者函数" class="headerlink" title="都可以描述一个对象或者函数"></a><strong>都可以描述一个对象或者函数</strong></h5><ul>
<li><strong>interface</strong></li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SetUser &#123;</span><br><span class="line">  (name: <span class="built_in">string</span>, age: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>type</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SetUser = <span class="function">(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)=&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>都允许拓展（extends)</strong></p>
<p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。</p>
<p><strong>虽然效果差不多，但是两者语法不同</strong>。</p>
<ul>
<li><p><strong>interface extends interface</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Name &#123;</span><br><span class="line"> name: <span class="built_in">string</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123;</span><br><span class="line"> age: <span class="built_in">number</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>type extends type</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = &#123; </span><br><span class="line"> name: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User = Name &amp; &#123; age: <span class="built_in">number</span>  &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>interface extends type</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = &#123; </span><br><span class="line"> name: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123; </span><br><span class="line"> age: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>type extends interface</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Name &#123; </span><br><span class="line">  name: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User = Name &amp; &#123; </span><br><span class="line">  age: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><ul>
<li><p><strong>type 可以而 interface 不行</strong></p>
<ul>
<li><p><strong>type 可以声明基本类型别名，联合类型，元组等类型</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本类型别名</span></span><br><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">    wong();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pet = Dog | Cat</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体定义数组每个位置的类型</span></span><br><span class="line"><span class="keyword">type</span> PetList = [Dog, Pet]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当你想获取一个变量的类型时，使用 typeof</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">type</span> B = <span class="keyword">typeof</span> div</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>其他骚操作</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringOrNumber = <span class="built_in">string</span> | <span class="built_in">number</span>;  </span><br><span class="line"><span class="keyword">type</span> Text = <span class="built_in">string</span> | &#123; text: <span class="built_in">string</span> &#125;;  </span><br><span class="line"><span class="keyword">type</span> NameLookup = Dictionary&lt;<span class="built_in">string</span>, Person&gt;;  </span><br><span class="line"><span class="keyword">type</span> Callback&lt;T&gt; = <span class="function">(<span class="params">data: T</span>) =&gt;</span> <span class="built_in">void</span>;  </span><br><span class="line"><span class="keyword">type</span> Pair&lt;T&gt; = [T, T];  </span><br><span class="line"><span class="keyword">type</span> Coordinates = Pair&lt;<span class="built_in">number</span>&gt;;  </span><br><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>interface 可以而 type 不行</strong> </p>
<ul>
<li><p><strong>interface 能够声明合并</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  sex: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">User 接口为 &#123;</span></span><br><span class="line"><span class="comment">  name: string</span></span><br><span class="line"><span class="comment">  age: number</span></span><br><span class="line"><span class="comment">  sex: string </span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>一般来说，如果不清楚什么时候用interface/type，能用 interface 实现，就用 interface , 如果不能就用 type 。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>vue生命周期</title>
    <url>/chayaBlog/2019/03/26/vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>在 vue 的官方文档中，我们可以看到 vue 的整个生命。</p>
<p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="01"></p>
<p>vue 主要给我们提供了如下八个钩子：beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestory、destoryed</p>
<p>首先我们先粗略的了解一下，vue 初始化的时候会做哪些事情。</p>
<ul>
<li>挂载生命周期钩子</li>
<li>解析 data 属性，将 data 属性转化为 Observer</li>
<li>解析模板，编译模板</li>
<li>挂载节点</li>
</ul>
<h2 id="各生命周期的含义"><a href="#各生命周期的含义" class="headerlink" title="各生命周期的含义"></a>各生命周期的含义</h2><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><p>在 <code>beforeCreate</code> 的时候，<code>vue</code> 只是将各生命周期注册的方法挂载到对应的钩子上，此时还未对 <code>data</code> 中的元素做初始化</p>
<h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>这个阶段主要完成了将<code>data</code>转化为<code>Observer</code>,此时还未对模板进行编译</p>
<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>这个阶段主要做了两个事</p>
<ol>
<li>检查vue配置，即new Vue{}里面的el项是否存在，有就继续检查template项。没有则等到手动绑定调用vm.$mount()</li>
<li>检查配置中的template项，如果没有template进行填充被绑定区域，则被绑定区域的el对象的outerHTML（即整个#app DOM对象，包括<div id="”app”">和</div>标签）都作为被填充对象替换掉填充区域</li>
</ol>
<p>此时模板还未进行编译。</p>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>这个阶段完成了对模板的编译，并完成了元素的挂载。</p>
<h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>数据改变时，会进入这个钩子</p>
<h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><p>组件更新之后，会进入这个钩子</p>
<h3 id="beforeDestory"><a href="#beforeDestory" class="headerlink" title="beforeDestory"></a>beforeDestory</h3><p>组件销毁前调用</p>
<h3 id="destoryed"><a href="#destoryed" class="headerlink" title="destoryed"></a>destoryed</h3><p>组件销毁后调用</p>
<h2 id="父子组件的加载顺序"><a href="#父子组件的加载顺序" class="headerlink" title="父子组件的加载顺序"></a>父子组件的加载顺序</h2><p>vue 在编译模板的时候，最先读进去的是根元素，然后一层一层的递归进子模板。</p>
<p>编译完成之后，在从子组件开始一层一层向外挂载。</p>
<p>总的来说就是，从创建到编译，是从父到子，从编译到挂载，是由子到父。</p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h2><p>在 vue 中，数据更新的时候并不会立刻去更新视图，而是会先将数据放入队列中异步的去更新视图。通过 <code>$nextTick</code> 我们就可以在视图更新之后再去调用方法了。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>快速理解 js 模块规范</title>
    <url>/chayaBlog/2018/10/13/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>随着前端的日益壮大，前端模块化的编程成为了一个非常重要的东西，这可以更好的帮我们构造工程化的前端项目。</p>
<p>说道前端模块规范，我们耳熟能详的就这三种 <code>CommonJS</code>, <code>AMD</code>, <code>CMD</code></p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义模块math.js</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="comment">//在这里写上需要向外暴露的函数、变量</span></span><br><span class="line">  add: add,</span><br><span class="line">  basicNum: basicNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用自定义的模块时，参数包含路径，可省略.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用核心模块时，不需要带路径</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createService(...).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>
<h3 id="AMD和require-js"><a href="#AMD和require-js" class="headerlink" title="AMD和require.js"></a>AMD和require.js</h3><p>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。</p>
<p>首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置<code>require.config()</code>并规定项目中用到的基础模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 网页中引入require.js及main.js **/</span></span><br><span class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>** main.js 入口文件/主模块 **<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="regexp">require.config(&#123;</span></span><br><span class="line"><span class="regexp">  baseUrl: "js/</span>lib<span class="string">",</span></span><br><span class="line"><span class="string">  paths: &#123;</span></span><br><span class="line"><span class="string">    "</span>jquery<span class="string">": "</span>jquery.min<span class="string">",  //实际路径为js/lib/jquery.min.js</span></span><br><span class="line"><span class="string">    "</span>underscore<span class="string">": "</span>underscore.min<span class="string">",</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">// 执行基本操作</span></span><br><span class="line"><span class="string">require(["</span>jquery<span class="string">","</span>underscore<span class="string">"],function($,_)&#123;</span></span><br><span class="line"><span class="string">  // some code here</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>引用模块的时候，我们将模块名放在<code>[]</code>中作为<code>reqiure()</code>的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在<code>[]</code>中作为<code>define()</code>的第一参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义math.js模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        basicNum :basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义一个依赖underscore.js的模块</span></span><br><span class="line">define([<span class="string">'underscore'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">_</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> classify = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">    _.countBy(list,<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num &gt; <span class="number">30</span> ? <span class="string">'old'</span> : <span class="string">'young'</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用模块，将模块放在[]内</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'jquery'</span>, <span class="string">'math'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">  $(<span class="string">"#sum"</span>).html(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="CMD和sea-js"><a href="#CMD和sea-js" class="headerlink" title="CMD和sea.js"></a>CMD和sea.js</h3><p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">      b.foo()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** AMD写法 **/</span></span><br><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) </span>&#123; </span><br><span class="line">     <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">        b.doSomething()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CMD写法 **/</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>); <span class="comment">//在需要时申明</span></span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** sea.js **/</span></span><br><span class="line"><span class="comment">// 定义模块 math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>);</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    exports.add = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">'math.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = math.add(<span class="number">1</span> , <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    ele.textContent = add(<span class="number">99</span> , basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上例所示，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了<code>export default</code>命令，为模块指定默认输出，对应的<code>import</code>语句不需要使用大括号。这也更趋近于ADM的引用写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** export default **/</span></span><br><span class="line"><span class="comment">//定义输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; basicNum, add &#125;;</span><br><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    ele.textContent = math.add(<span class="number">99</span> , math.basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6的模块不是对象，<code>import</code>命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>
<h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><h5 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="1.  CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>1.  CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h5><ul>
<li><p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p>
</li>
<li><p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的原始值变了，<code>impor</code>t加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块.</p>
</li>
</ul>
<h5 id="2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h5><ul>
<li><p>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</p>
</li>
<li><p>译编译时加载:ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</p>
</li>
</ul>
<p>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
]]></content>
      <categories>
        <category>模块化</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈es6的模块化</title>
    <url>/chayaBlog/2018/07/28/%E6%A8%A1%E5%9D%97%E5%8C%96/about-es6-module/</url>
    <content><![CDATA[<p>如今模块化的编程方式，已经成为了每个前端程序员必须掌握的一门技术，es6 也带了 <code>import</code> 和 <code>export</code> 两个新语法，搞清楚他们的作用和用法也是我们所必须要学习的。</p>
<h2 id="需要注意的一些概念"><a href="#需要注意的一些概念" class="headerlink" title="需要注意的一些概念"></a>需要注意的一些概念</h2><ul>
<li>首先，es6 的模块是基于文件的模块，在浏览器端还不支持 <code>import</code> 和 <code>export</code> 语法，我们开发过程使用，也是需要通过打包工具将其编译为 es5 的语法才能使用。</li>
<li>es6 的模块是单利的，也就是说，模块只有一个实例，每次我们 <code>import</code> 的时候，其实都是同一个对象。如果需要有多个模块实例的话，则需要通过 <code>export</code> 一个工厂方法来实现</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>es6 模块主要就是两个新的关键字 <code>import</code> 和 <code>export</code></p>
<h3 id="named-export-命名导出"><a href="#named-export-命名导出" class="headerlink" title="named export (命名导出)"></a>named export (命名导出)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> awesome = <span class="string">'awesome'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'test'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  test,</span><br><span class="line">  awesome</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在模块内作用域都是局部的，只要没有 <code>export</code> 出去，外面就无法访问到。</p>
<p>我们也可以在导出的时候给成员重命名 <code>export { test as try }</code>。</p>
<h3 id="模块是单例的"><a href="#模块是单例的" class="headerlink" title="模块是单例的"></a>模块是单例的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// test.js</span><br><span class="line">let name = &apos;test&apos;;</span><br><span class="line">export &#123;name&#125;;</span><br><span class="line"></span><br><span class="line">// index.js</span><br><span class="line">import &#123; name &#125; from &apos;./test&apos;;</span><br><span class="line">name = &apos;index change it&apos;;</span><br><span class="line"></span><br><span class="line">// getname.js</span><br><span class="line">import &#123; name &#125; from &apos;./test&apos;;</span><br><span class="line">console.log(name); // index change it</span><br></pre></td></tr></table></figure>
<p>当我们在 index.js 修改了从 test.js import 进来的 name，之后我们再在 getname.js 中 import 它，这时候我们就会发现这个值就被修改了。</p>
<p>这是因为在 import 的时候，我们本质上可以看做是引了一个对变量的指针。虽然有这个特性，但是我们应该避免使用这个特性，<br>因为这会增大我们程序的复杂度，会使得程序变得难以维护，追踪变量在哪里被修改是非常麻烦的。</p>
<h3 id="export-default-默认导出"><a href="#export-default-默认导出" class="headerlink" title="export default (默认导出)"></a>export default (默认导出)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'test'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name;</span><br></pre></td></tr></table></figure>
<p>当文件中有默认导出的时候我们可以通过下面几种方式得到这个值</p>
<ul>
<li><p><code>import name from &#39;./test&#39;</code> 这个 name 也可以叫其他名字比方说<code>import test from &#39;./test&#39;</code> 这里 name 和 test 其实指的是同一个东西</p>
</li>
<li><p><code>import { default as name } from &#39;./test</code> 这里的 default 不能省略</p>
</li>
</ul>
<h3 id="namespace-import-命名空间引入"><a href="#namespace-import-命名空间引入" class="headerlink" title="namespace import (命名空间引入)"></a>namespace import (命名空间引入)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> test <span class="keyword">from</span> <span class="string">'./test'</span></span><br><span class="line"><span class="built_in">console</span>.log(test.name);</span><br></pre></td></tr></table></figure>
<p>es6 的设计理念是让我们按需引用，不过还是看具体的需要，如果引入的模块比较小的话，<br>我们还是可以通过使用命名空间引入的方式来进行引用。</p>
<h3 id="import-立执行的函数"><a href="#import-立执行的函数" class="headerlink" title="import 立执行的函数"></a>import 立执行的函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'rxjs/operators/add'</span>;</span><br></pre></td></tr></table></figure>
<p>有时候我们会看到一些类似于上面的用法，这些一般加载的是一些立执行的函数，一般我们也要避免使用这种，因为他会导致你的代码变得难以理解，后来的 rxjs6 也修改了这种用法</p>
]]></content>
      <categories>
        <category>模块化</category>
      </categories>
  </entry>
  <entry>
    <title>LRU (最近最少使用) 缓存机制</title>
    <url>/chayaBlog/2020/05/12/%E7%AE%97%E6%B3%95/LRU/</url>
    <content><![CDATA[<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p><strong>LRU (最近最少使用) 缓存机制</strong>。</p>
<p>支持以下操作： 获取数据 get 和 写入数据 put 。<br>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。<br>当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<p>示例:  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> ); <span class="comment">// 缓存容量  </span></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);  </span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);  </span><br><span class="line">cache.get(<span class="number">1</span>); <span class="comment">// 返回 1  </span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// 该操作会使得密钥 2 作废  </span></span><br><span class="line">cache.get(<span class="number">2</span>); <span class="comment">// 返回 -1 (未找到)  </span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>); <span class="comment">// 该操作会使得密钥 1 作废  </span></span><br><span class="line">cache.get(<span class="number">1</span>); <span class="comment">// 返回 -1 (未找到)  </span></span><br><span class="line">cache.get(<span class="number">3</span>); <span class="comment">// 返回 3  </span></span><br><span class="line">cache.get(<span class="number">4</span>); <span class="comment">// 返回 4</span></span><br></pre></td></tr></table></figure>
<p>通过ES6 的Map实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">capacity</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> LRUCache = <span class="function"><span class="keyword">function</span> (<span class="params">capacity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">  <span class="keyword">this</span>.map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">key</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.map.has(key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>.map.get(key);</span><br><span class="line">  <span class="keyword">this</span>.map.delete(key);</span><br><span class="line">  <span class="keyword">this</span>.map.set(key, value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">key</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.map.has(key)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.map.delete(key);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.map.size &gt;= <span class="keyword">this</span>.capacity) &#123;</span><br><span class="line">    <span class="keyword">this</span>.map.delete(<span class="keyword">this</span>.map.keys().next().value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.map.set(key, value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>判断两颗树是否对称</title>
    <url>/chayaBlog/2020/04/24/%E7%AE%97%E6%B3%95/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="判断两颗树是否对称"><a href="#判断两颗树是否对称" class="headerlink" title="判断两颗树是否对称"></a>判断两颗树是否对称</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isSymmetricTree = <span class="function">(<span class="params">tree1, tree2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree1 &amp;&amp; !tree2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!tree1 || !tree2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree1.val !== tree2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetricTree(tree1.left, tree2.right) &amp;&amp; isSymmetricTree(tree1.right, tree2.left);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> isSymmetricTree(root, root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/chayaBlog/2020/04/15/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序从小到大排序：一开始交换的区间为0~N-1，将第1个数和第2个数进行比较，前面大于后面，交换两个数，否则不交换。再比较第2个数和第三个数，前面大于后面，交换两个数否则不交换。依次进行，最大的数会放在数组最后的位置。然后将范围变为0~N-2，数组第二大的数会放在数组倒数第二的位置。依次进行整个交换过程，最后范围只剩一个数时数组即为有序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">        [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>平均时间复杂度:O(n²)</strong><br><strong>最坏时间复杂度:O(n²)</strong><br><strong>最好时间复杂度:O(n)</strong></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序从小到大排序：在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边部分，大于此数的放在右边部分，这个操作确保了这个数是处于正确位置的，再对左边部分数组和右边部分数组递归调用快速排序，重复这个过程。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_quickSort</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> i = left, j = right, pivot = arr[left];</span><br><span class="line">    <span class="keyword">while</span> (i !== j) &#123;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; i &amp;&amp; arr[j] &gt;= pivot) &#123;</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; i &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">      [arr[left], arr[i]] = [arr[i], arr[left]];</span><br><span class="line">    &#125;</span><br><span class="line">    _quickSort(left, i - <span class="number">1</span>);</span><br><span class="line">    _quickSort(i + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _quickSort(<span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>平均时间复杂度:O(nlogn)</strong><br><strong>最坏时间复杂度:O(n²)</strong><br><strong>最好时间复杂度:O(nlogn)</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP 区别</title>
    <url>/chayaBlog/2019/10/20/%E7%BD%91%E7%BB%9C/HTTP%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP的基本优化"><a href="#HTTP的基本优化" class="headerlink" title="HTTP的基本优化"></a>HTTP的基本优化</h4><p>影响HTTP网络请求的主要因素有两个：<strong>带宽</strong> 和 <strong>延迟</strong></p>
<ul>
<li><p><strong>带宽：</strong> 现在网络基础建设使得带宽得到极大的提升，不再会担心带宽而影响网络</p>
</li>
<li><p><strong>延迟：</strong></p>
<ul>
<li><p><strong>浏览器阻塞：</strong> 浏览器对于同一个域名，同时只能有4个连接（不同浏览器内核会有差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</p>
</li>
<li><p><strong>DNS查询：</strong> 浏览器需要知道目标服务器的IP才能进行连接。将域名解析成IP的系统就是DNS。这个通常可以通过利用DNS缓存来减少时间。</p>
</li>
<li><p><strong>建立连接：</strong> HTTP是基于TCP协议的，浏览器最快也只能在第三次握手时才能捎带HTTP请求报文，达到真正的请求连接，但是这些连接无法复用就会导致每次请求都要经历三次握手和慢启动。三次握手在高延迟的场景下的比较明显，慢启动则对文件类大请求影响较大。</p>
</li>
</ul>
</li>
</ul>
<h4 id="HTTP1-0-和-HTTP1-1区别"><a href="#HTTP1-0-和-HTTP1-1区别" class="headerlink" title="HTTP1.0 和 HTTP1.1区别"></a>HTTP1.0 和 HTTP1.1区别</h4><ol>
<li><p><strong>缓存处理：</strong> 在HTTP1.0中主要使用header里的If-Modified-Since，Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since，If-Match，If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p><strong>宽带优化以及网络连接的使用：</strong> HTTP1.0中，存在一些浪费带宽的现象，例如客户端只需要某个对象的一部分，而服务器却将整个对象都返回了，并且不支持断电续传功能，HTPP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
</li>
<li><p><strong>错误通知的管理：</strong> 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</li>
<li><p><strong>HOST头处理：</strong> 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持HOST头域，且请求消息中如果没有HOST头域就会报错（400 Bad Request）</p>
</li>
<li><p><strong>长链接：</strong> HTTP1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>
</li>
</ol>
<h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><ol>
<li><p>HTTPS需要到CA申请证书，一般免费证书很少，需要交费</p>
</li>
<li><p>HTTP协议运行在TCP之上，所有传输内容都是明文，HTTPS协议运行在SSL/TLS之上，SSL/TLS运行都在TCP之上，所有传输内容都是加密的。</p>
</li>
<li><p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不同，前者是80，后者是443</p>
</li>
<li><p>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</p>
</li>
</ol>
<h4 id="HTTP2-0和HTTP1-X相比的新特性"><a href="#HTTP2-0和HTTP1-X相比的新特性" class="headerlink" title="HTTP2.0和HTTP1.X相比的新特性"></a>HTTP2.0和HTTP1.X相比的新特性</h4><ol>
<li><p><strong>新的二进制格式：</strong> HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p>
</li>
<li><p><strong>多路复用：</strong> 即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p>
</li>
<li><p><strong>header压缩：</strong> HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>
</li>
<li><p><strong>服务端推送：</strong> HTTP2.0具有server push功能。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>http 缓存</title>
    <url>/chayaBlog/2019/03/20/%E7%BD%91%E7%BB%9C/HTTP%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>http 常见的状态码有很多，200，302，303，304，403，500等，其中要数304在面试中最常被问到。初学者碰到304，可能只是知道他是用于缓存，却并不知道其中的原理。下面我们来了解一下304整个的运行机制。</p>
<h2 id="缓存运行机制"><a href="#缓存运行机制" class="headerlink" title="缓存运行机制"></a>缓存运行机制</h2><p>浏览器通过请求头来判断一个资源是否需要缓存  </p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>在 http1.1 中我们通过请求头中的 <code>Cache-Control</code> 来告诉浏览器缓存机制。</p>
<p>作为响应头其中可选的值有：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>表示任何情况下都得缓存该资源</td>
</tr>
<tr>
<td>Private=[=”field-name”]</td>
<td>表明返回报文中全部或部分仅开放给某些用户作缓存（服务器指定的，如代理服务器等），其他用户则不能缓存这些数据</td>
</tr>
<tr>
<td>no-cache</td>
<td>不直接使用缓存，要向服务器发起新鲜度校验</td>
</tr>
<tr>
<td>no-store</td>
<td>所有内容不会被缓存</td>
</tr>
<tr>
<td>no-transform</td>
<td>告知客户端缓存文件时不得对实体数据做任何改变</td>
</tr>
<tr>
<td>only-if-cached</td>
<td>告知代理服务器，如果客户端需要的数据，代理服务器有，代理服务器不用想原服务器发送请求</td>
</tr>
<tr>
<td>must-revalidate</td>
<td>资源一定是向员服务器去验证请求，若请求失败会返回504</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>与must-revalidate类似</td>
</tr>
<tr>
<td>max-age=delta-seconds</td>
<td>告知客户端在 delta-seconds 内资源是新鲜的，不用向服务器发起请求</td>
</tr>
<tr>
<td>s-maxage=delta-seconds</td>
<td>和max-age一样，但仅应用于共享缓存（如代理）</td>
</tr>
<tr>
<td>cache-extension</td>
<td>自定义拓展值</td>
</tr>
</tbody>
</table>
<p>其中常用的主要是 max-age。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age=100</span><br></pre></td></tr></table></figure>
<p>这个请求头的意思是告诉浏览器该资源在100秒内都是新鲜的。<br><strong>强缓存：</strong> 如果未过期，则不用向服务器发送请求，直接读取缓存。</p>
<p>强缓存的200状态码分为：</p>
<p><strong>200 form memory cache(内存缓存)</strong></p>
<p>不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。<strong>浏览器关闭后，数据将不存在</strong>（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。</p>
<p><strong>200 form disk cache(磁盘缓存)</strong></p>
<p>不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，<strong>关闭浏览器后，数据依然存在</strong>，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。</p>
<p>若过期了，则会重新像服务器发起请求。</p>
<h3 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h3><p>现在我们已经知道了如何通知浏览器做缓存了，但是这里还有一个问题，缓存到期了，浏览器重新请求资源，但是如果资源在这段时间并没有发生修改，又重新把资源发送了一遍，如果资源又比较大，这就造成很大的宽带和时间的浪费。</p>
<p><strong>协商缓存：</strong> 304状态码就是用来告诉浏览器，资源还没更新过，还是可以从缓存中读取资源。</p>
<p>如何验证资源是否被修改过：</p>
<p>http 1.1 新增了几个首部字段来解决这个问题。</p>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>服务器将资源返回给浏览器的时候，会将资源的最后修改时间加在请求头上返回给浏览器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Last-Modified: Thu, 01 Jan 1970 00:00:00 GMT</span><br></pre></td></tr></table></figure>
<p>浏览器接收之后，会在下一次的请求把信息附带上，到服务器去做检查，若与服务器的修改时间一直，则说明资源没有被修改过，直接返回304即可。</p>
<p>浏览器会通过<code>if-modified-since</code>将信息发送给服务器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if-modified-since: Sun, 18 Mar 2018 13:01:31 GMT</span><br></pre></td></tr></table></figure></p>
<p>Last-Modified 也可能会出现一个问题，如果服务器上，一个资源被修改了，但是实质上内容根本没有发生变化，也会重新发送整个资源给浏览器。</p>
<h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p>为了解决上面这个问题，Http1.1还加入了ETag这个首部。服务器通过某种算法，给资源计算出一个唯一的表示符，并在响应头上返回给浏览器。</p>
<p>浏览器会在下一次请求的时候，通过<code>If-None-Match</code>将信息发送给服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If-None-Match: &quot;sdfsfedc8-2132&quot;</span><br></pre></td></tr></table></figure>
<p>如果匹配上了则直接返回304即可，没匹配上则需要重新发送资源。</p>
<blockquote>
<p>需要注意的是，如果这两个字段被同时使用了，需要他们两个同时验证通过才会返回304，如果其中一个没验证通过，都会重新发送资源</p>
</blockquote>
]]></content>
      <categories>
        <category>http</category>
      </categories>
  </entry>
  <entry>
    <title>Web 安全之 xss和csrf攻击</title>
    <url>/chayaBlog/2018/08/01/%E7%BD%91%E7%BB%9C/xss%E5%92%8Ccsrf%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>xss 和 csrf 可以说是最常见的攻击手段，面试也很大概率会问到这两个东西，下面我们可以了解一下他们是什么。</p>
<h2 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h2><p>xss 也叫跨站脚本攻击。是一种非常常见的攻击手段，我们可以把它看做是一个html注入攻击。和我们长听到的sql注入非常的类似。</p>
<h3 id="常见的-xss-攻击方式。"><a href="#常见的-xss-攻击方式。" class="headerlink" title="常见的 xss 攻击方式。"></a>常见的 xss 攻击方式。</h3><h4 id="通过-url-注入"><a href="#通过-url-注入" class="headerlink" title="通过 url 注入"></a>通过 url 注入</h4><p>比方说A网站有个内容是通过url中的参数来显示的，并且没有对其做任何的xss防范，那么攻击者就可以通过url将攻击脚本注入到网页中，然后将带有攻击脚本的url进行特殊处理，然后将处理后的url发给第三者完成攻击</p>
<h4 id="通过一些表单输入做注入"><a href="#通过一些表单输入做注入" class="headerlink" title="通过一些表单输入做注入"></a>通过一些表单输入做注入</h4><p>最常见得就是富文本评论，因为需要保持html的原样，所以就很容易被人注入攻击脚本，当其他用户访问了被注入攻击脚本的页面的时候就会被攻击。</p>
<h3 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h3><p>对xss的防御思路，主要有两种，可以看我们具体的需求来决定使用哪一种。</p>
<h4 id="http-only"><a href="#http-only" class="headerlink" title="http-only"></a>http-only</h4><p>这个东西主要针对的是cookie，在 xss 注入的时候可能会有js盗取cookie，我们可以将 cookie 设置为http-only,这样 js 就会无法操作cookie，不过这也仅仅防范了这一种可能性，还是无法防御其他手段的 xss 攻击</p>
<h4 id="设置黑名单"><a href="#设置黑名单" class="headerlink" title="设置黑名单"></a>设置黑名单</h4><p>通过设置黑名单，将一些特殊的字段进行删除或者转译来达到防御的手段，比方说 <code>&lt;script&gt;</code>，黑名单的实现比较简单，但是 xss 攻击的花样非常的多，我们很难知道所有的攻击手段，很有可能会造成攻击漏洞。</p>
<h4 id="设置白名单"><a href="#设置白名单" class="headerlink" title="设置白名单"></a>设置白名单</h4><p>白名单的思路也很简单，我们根据我们的需求设置允许使用的标签和属性，然后把不在白名单中的标签或者属性都去掉，在实现上会比黑名单复杂一点，需要把进行防御的内容转为树状结构进行遍历然后处理掉白名单以为的标签和属性。</p>
<h4 id="CSP-Content-Security-Policy"><a href="#CSP-Content-Security-Policy" class="headerlink" title="CSP (Content Security Policy)"></a>CSP (Content Security Policy)</h4><p>内容安全策略，用于指定哪些内容可以被执行。通过设置 <code>Content-Security-Policy</code> 响应头我们可以设置哪些内容是可以执行的。</p>
<p>csp 本质上也是一个白名单，我们通过配置告诉浏览器哪些内容是可以安全执行的。</p>
<p>具体的配置我们可以去 MDN 上查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid/default-src" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid/default-src</a></p>
<p>相关知识可以看看阮老师的这篇文章 <a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/csp.html</a></p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>csrf 也叫跨站请求伪造。攻击方式就是第三方的网站可以在用户不知情的情况下发送请求到被攻击的网站上。比方说网站A，我们有一个网站B会偷偷帮用户发请求到A，发送的时候浏览器会自动的挟带上A的cookie，而A又是对cookie做验证，这就导致了 csrf 攻击</p>
<h3 id="防御方式-1"><a href="#防御方式-1" class="headerlink" title="防御方式"></a>防御方式</h3><h4 id="设置-cookie-的-sameSite"><a href="#设置-cookie-的-sameSite" class="headerlink" title="设置 cookie 的 sameSite"></a>设置 <code>cookie</code> 的 <code>sameSite</code></h4><p><code>sameSite</code> 可以禁止来自第三方网站的请求携带 cookie，他有两个值</p>
<ul>
<li><code>Strict</code> 禁止一切请求携带 cookie</li>
<li><code>Lax</code> 允许一部分请求携带 cookie，比方说链接</li>
</ul>
<p>不过目前这还是一个试验箱的属性，只有部分浏览器支持这个值。</p>
<h4 id="增加验证"><a href="#增加验证" class="headerlink" title="增加验证"></a>增加验证</h4><p>验证的方式有很多，可以有如下几种</p>
<ul>
<li>验证码，不过验证码可能会带来比较不好的用户体验</li>
<li>token，在表单或者请求头中增加一个token做验证</li>
<li>referer验证，referer需要在后端进行，这个单词其实拼写错误的，原本应该是referrer，我们可以通过referer来判断请求是否来源于当前网站，如果不是则判定为非法请求</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器验证CA证书</title>
    <url>/chayaBlog/2018/09/10/%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%AA%8C%E8%AF%81CA%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h3><p>首先CA是Certificate Authority的缩写，也叫“证书授权中心”。<br>它是负责管理和签发证书的第三方机构，就好比例子里面的中介——C 公司。<br>一般来说，CA必须是所有行业和所有公众都信任的、认可的。因此它必须具有足够的权威性。就好比A、B两公司都必须信任C公司，才会找 C 公司作为公章的中介。</p>
<h3 id="CA-证书"><a href="#CA-证书" class="headerlink" title="CA 证书"></a>CA 证书</h3><p> 顾名思义，就是CA颁发的证书。</p>
<p> 浏览器中默认有得到认证的根证书，使用https的网站需要让浏览器信任自己的证书就需要去申请这些机构的证书</p>
<h2 id="浏览如何验证证书的真伪呢？"><a href="#浏览如何验证证书的真伪呢？" class="headerlink" title="浏览如何验证证书的真伪呢？"></a>浏览如何验证证书的真伪呢？</h2><p> 首先我们需要了解一下CA是如何给我们发证书的。</p>
<p> 1.向CA申请证书<br> 2.CA认证了你的信息之后同意给你颁布证书，生成证书信息，生成证书的指纹用于后面验证证书的真伪<br> 3.使用私钥对指纹进行加密生成数字签名，常用的算法有RSA公钥体制<br> 4.将证书颁发网站，生成的证书会指向给他颁发证书的CA</p>
<p> 了解完CA证书的生成之后我们就可以看一下浏览器如何验证证书的了。</p>
<p> 1.浏览器拿到证书之后会找到证书所对应的CA<br> 2.浏览器取出CA中的公钥，使用公钥对证书的签名进行解密<br> 3.将解密的结果与证书指纹做对比，如果对比一致则说明真书是真的<br> 4.浏览器提取出证书中的公钥使用</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>发布订阅模式</title>
    <url>/chayaBlog/2018/03/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>目前非常流行的 vue 的底层，其实用的就是发布订阅模式。要学习vue的原理的话，很有必要先学习一下这个设计模式。</p>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>在观察者模式中一般有两个对象发布者和订阅者，订阅者从发布者那里订阅消息，发布者发布消息通知所有订阅消息的对象。当订阅者订阅发布者的时候，发布者会把订阅者添加到自己的订阅者列表中。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Publisher</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">发布者添加订阅对象</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">Publisher.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">observer</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">发布者通知订阅者</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">Publisher.prototype.notify = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function">(<span class="params">observer</span>)=&gt;</span>&#123;</span><br><span class="line">        observer.update(context)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observer.prototype.update=<span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    订阅发布者</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">Observer.prototype.subscribe=<span class="function"><span class="keyword">function</span>(<span class="params">publisher</span>)</span>&#123;</span><br><span class="line">    publisher.add(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> Observer();</span><br><span class="line"></span><br><span class="line">observer.subscribe(publisher);</span><br><span class="line">publisher.notify(<span class="string">'事件发布'</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>发布订阅模式</title>
    <url>/chayaBlog/2019/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3></li>
</ul>
<blockquote>
<p>常见的实例化对象模式，工厂模式就相当于创建实例对象的new，提供一个创建对象的接口</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 某个需要创建的具体对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    init () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 工厂对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</span><br><span class="line">    create (name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> creator = <span class="keyword">new</span> Creator();</span><br><span class="line"><span class="keyword">const</span> p = creator.create(); <span class="comment">// 通过工厂对象创建出来的具体对象</span></span><br></pre></td></tr></table></figure>
<p>  应用场景：JQuery中的$、Vue.component异步组件、React.createElement等</p>
<ul>
<li><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3></li>
</ul>
<blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点，一般登录、购物车等都是一个单例。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例对象</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</span><br><span class="line">       login () &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 访问方法</span></span><br><span class="line">   SingleObject.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">let</span> instance;</span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">               instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> instance;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)();</span><br><span class="line">   <span class="keyword">const</span> obj1 = SingleObject.getInstance();</span><br><span class="line">   <span class="keyword">const</span> obj2 = SingleObject.getInstance();</span><br><span class="line">   <span class="built_in">console</span>.log(obj1 === obj2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>应用场景：JQuery中的$、Vuex中的Store、Redux中的Store等</p>
<ul>
<li><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3></li>
</ul>
<blockquote>
<p>用来解决两个接口不兼容问题，由一个对象来包装不兼容的对象，比如参数转换，允许直接访问</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">       specificRequest () &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">'德国标准插头'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// 适配器对象，对原来不兼容对象进行包装处理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">       <span class="keyword">constructor</span> () &#123;</span><br><span class="line">           <span class="keyword">this</span>.adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">       &#125;</span><br><span class="line">       request () &#123;</span><br><span class="line">           <span class="keyword">const</span> info = <span class="keyword">this</span>.adapter.specificRequest();</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;info&#125;</span> - 转换器 - 中国标准插头`</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">const</span> target = <span class="keyword">new</span> Target();</span><br><span class="line"> <span class="built_in">console</span>.log(target.request()); <span class="comment">// 德国标准插头 - 转换器 - 中国标准插头</span></span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3></li>
</ul>
<blockquote>
<p>在不改变对象自身的基础上，动态的给某个对象添加新的功能，同时又不改变其接口</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> </span>&#123;</span><br><span class="line">    fire () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'发送普通子弹'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 装饰过的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Missile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (plane) &#123;</span><br><span class="line">        <span class="keyword">this</span>.plane = plane;</span><br><span class="line">    &#125;</span><br><span class="line">    fire () &#123;</span><br><span class="line">        <span class="keyword">this</span>.plane.fire();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'发射导弹'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> plane = <span class="keyword">new</span> Plane();</span><br><span class="line">plane = <span class="keyword">new</span> Missile(plane);</span><br><span class="line"><span class="built_in">console</span>.log(plane.fire()); <span class="comment">// 依次打印 发送普通子弹 发射导弹</span></span><br></pre></td></tr></table></figure>
<p>应用场景：ES7装饰器、Vuex中1.0版本混入Vue时，重写init方法、Vue中数组变异方法实现等</p>
<ul>
<li><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3></li>
</ul>
<blockquote>
<p>为其他对象提供一种代理，便以控制对这个对象的访问，不能直接访问目标对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flower</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 源对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (target) &#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    sendFlower (target) &#123;</span><br><span class="line">        <span class="keyword">const</span> flower = <span class="keyword">new</span> Flower();</span><br><span class="line">        <span class="keyword">this</span>.target.receiveFlower(flower)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rose</span> </span>&#123;</span><br><span class="line">    receiveFlower (flower) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'收到花: '</span> + flower)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyObj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.target = <span class="keyword">new</span> Rose();</span><br><span class="line">    &#125;</span><br><span class="line">    receiveFlower (flower) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sendFlower(flower)</span><br><span class="line">    &#125;</span><br><span class="line">    sendFlower (flower) &#123;</span><br><span class="line">        <span class="keyword">this</span>.target.receiveFlower(flower)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> ProxyObj();</span><br><span class="line"><span class="keyword">const</span> jack = <span class="keyword">new</span> Jack(proxyObj);</span><br><span class="line">jack.sendFlower(proxyObj); <span class="comment">// 收到花：[object Object]</span></span><br></pre></td></tr></table></figure>
<p>应用场景：ES6 Proxy、Vuex中对于getters访问、图片预加载等</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
</search>
